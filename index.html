<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ—ºï¸ å‹‡è€…æ¨¡æ“¬å™¨ï¼šç¨€æœ‰åº¦åˆ†ç´šç‰ˆ</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px 0;
            background-color: #e8f5e9;
        }
        #game-container {
            width: 90%;
            max-width: 650px;
            padding: 20px;
            background-color: #fff;
            border: 5px solid #000;
            box-shadow: 6px 6px 0px #4caf50;
            text-align: center;
            margin-bottom: 20px;
        }
        #status-box {
            background-color: #f0f4c3;
            border: 2px solid #000;
            padding: 10px;
            margin-bottom: 15px;
            text-align: left;
            font-size: 14px;
        }
        /*#status-box .status-header {
            display: flex;
            justify-content: space-between;  /* å·¦å³å…©é‚Šè²¼é‚Š 
            align-items: center;
        }
        #turn-counter {
            font-weight: bold;
        }*/

        
        #equipment-status {
            margin-top: 4px;
        }
        #extra-status {
            margin-top: 4px;
        }
        #main-view {
            height: 180px;
            border: 3px solid #000;
            background-color: #1a2a3a;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            white-space: pre-wrap;
            line-height: 1.1;
            font-size: 18px;
            margin-bottom: 15px;
            transition: background-color 0.1s;
        }

        .transition-flash-on { background-color: #000000 !important; transition: none; }
        .transition-flash-off { background-color: #ffffff !important; transition: none; }

        .hero-hit-flash { background-color: #ffd700 !important; }
        .monster-hit-flash { background-color: #ff3333 !important; }
        .crit-flash { background-color: #ffaa00 !important; }
        .heal-flash { background-color: #33ff33 !important; }

        .loot-Magic { background-color: #003300 !important; color: #00aa00; font-size: 24px;}
        .loot-Rare { background-color: #000033 !important; color: #00aaff; font-size: 28px;}
        .loot-Epic { background-color: #330033 !important; color: #aa00aa; font-size: 30px;}
        .loot-Legendary { background-color: #331a00 !important; color: #FF8C00; font-size: 32px;}
        .loot-Mythic { background-color: #330000 !important; color: #FF0000; font-size: 34px;}
        .loot-Normal { background-color: #333333 !important; color: #ffffff; font-size: 20px;}

        #command-menu {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-bottom: 15px;
        }
        .command-btn {
            padding: 10px 15px;
            font-size: 16px;
            cursor: pointer;
            border: 2px solid #000;
            background-color: #ffcc00;
            box-shadow: 2px 2px 0px #000;
            flex-grow: 1;
            min-width: 100px;
            transition: background-color 0.2s;
        }
        .command-btn:hover:not(:disabled) { background-color: #ffd740; }
        .command-btn:disabled { background-color: #ccc; cursor: not-allowed; }

        .defend-btn {
            background-color: #2196F3;
            color: white;
            font-weight: bold;
        }

        #decision-menu {
            display: none;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
            padding: 10px 0;
            border-top: 2px solid #ccc;
        }
        .decision-btn {
            padding: 10px 15px;
            font-size: 16px;
            cursor: pointer;
            border: 2px solid #000;
            background-color: #f44336;
            color: white;
            box-shadow: 2px 2px 0px #000;
            flex-grow: 1;
            min-width: 150px;
        }
        .decision-btn-yes { background-color: #4CAF50; }
        .decision-btn-no { background-color: #F44336; }

        #message-log {
            min-height: 120px;
            border: 2px solid #000;
            padding: 10px;
            text-align: left;
            overflow-y: auto;
            max-height: 120px;
            background-color: #fcfcfc;
            font-size: 13px;
        }
        .log-msg { margin: 2px 0; }

        #equipment-display {
            margin-top: 15px;
            border: 2px solid #000;
            padding: 10px;
            text-align: left;
            background-color: #fcfcfc;
            font-size: 14px;
            line-height: 1.6;
        }

        .Rarity-Normal { color: #808080; }
        .Rarity-Magic { color: #00AA00; font-weight: bold; }
        .Rarity-Rare { color: #0000AA; font-weight: bold; }
        .Rarity-Epic { color: #AA00AA; font-weight: bold; }
        .Rarity-Legendary { color: #FF8C00; font-weight: bold; }
        .Rarity-Mythic { color: #FF0000; font-weight: bold; }

        #game-manual {
            width: 90%;
            max-width: 650px;
            padding: 20px;
            margin-top: 20px;
            background-color: #f9f9f9;
            border: 2px dashed #4caf50;
            text-align: left;
            font-size: 13px;
            line-height: 1.8;
        }
        #game-manual h3 {
            color: #2e7d32;
            border-bottom: 1px solid #4caf50;
            padding-bottom: 5px;
            margin-top: 15px;
        }
    </style>
</head>
<body>
<!-- ===== å‹‡è€…ç¨±è™Ÿé¸å–®ï¼ˆé€²éŠæˆ²å‰å‡ºç¾ï¼‰ ===== -->
<div id="titleSelectBox" style="
    position: fixed; inset: 0;
    background: rgba(0,0,0,0.6);
    display: flex; align-items: center; justify-content: center;
    z-index: 9999;
">
  <div style="
      background:#fffbea;
      border:3px solid #333;
      padding:16px 20px;
      min-width:320px;
      box-shadow:4px 4px 0 #333;
      font-family:'Courier New',monospace;
  ">
    <h3 style="margin-top:0;">ğŸ§¾ è«‹å…ˆå¹«è‡ªå·±é¸ä¸€å€‹ç¨±è™Ÿ</h3>
    <p style="font-size:14px;margin-top:0;">
      çµ„åˆæ–¹å¼ï¼š<b>Aå½¢å®¹è©</b> + çš„ + <b>Bå½¢å®¹è©</b> + <b>Cåè©</b><br>
      ç›´æ¥æŒ‰ã€Œé–‹å§‹å†’éšªã€æ²’é¸çš„è©±ï¼Œæœƒè‡ªå‹•å¹«ä½ æŠ½ä¸€çµ„éš¨æ©Ÿç¨±è™Ÿã€‚
    </p>
    <div style="margin-bottom:8px;">
      Aï¼š
      <select id="titleA"></select>
    </div>
    <div style="margin-bottom:8px;">
      Bï¼š
      <select id="titleB"></select>
    </div>
    <div style="margin-bottom:12px;">
      Cï¼š
      <select id="titleC"></select>
    </div>
    <div style="text-align:right;">
      <!-- <button onclick="randomTitleOnly()" style="margin-right:8px;">ğŸ² éš¨æ©Ÿä¸€çµ„çœ‹çœ‹</button>-->
      <button onclick="confirmTitle()">âœ… é–‹å§‹å†’éšª</button>
    </div>
  </div>
</div>
<!-- ===== ç¨±è™Ÿé¸å–®çµæŸ ===== -->


    <!-- éŠæˆ²ä¸»è¦–çª—ä»‹é¢ -->
<div id="game-container"> 
    <h1>ğŸ—ºï¸ å‹‡è€…æ¨¡æ“¬å™¨ï¼šæ‰“å¯¶èˆ‡é¤Šæˆ</h1>

          <div id="status-box">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <div>
                    å‹‡è€…<span id="hero-title"></span>: Lv.<span id="hero-level">1</span>
                    (EXP: <span id="hero-exp">0</span>/<span id="hero-exp-max">10</span>)<br>
                    HP: <span id="hero-hp">20</span> / <span id="hero-max-hp">20</span><br>
                    ATK: <span id="hero-atk-val">15</span> |
                    DEF: <span id="hero-def-val">10</span> |
                    MATK: <span id="hero-matk-val">20</span>
                </div>
        
                <!-- â­â­ é€™è¡Œæ˜¯ä½ è¦çš„ï¼šå³ä¸Šè§’å›åˆé¡¯ç¤º â­â­ -->
                <div id="turn-count" style="font-weight:bold; font-size:14px; margin-right:10px;">
                    å›åˆï¼š0
                </div>
            </div>
        </div>

    <div id="main-view">
        <p>æ­¡è¿ä¾†åˆ°å†’éšªä¸–ç•Œï¼</p>
    </div>

    <div id="command-menu">
        <button id="btn-action-1" class="command-btn" onclick="handleMapAction('Small')">å‡ºç™¼å†’éšª</button>
        <button id="btn-action-2" class="command-btn" onclick="handleMapAction('Boss')">æŒ‘æˆ° Boss å¯¶è—</button>
        <button id="btn-action-3" class="command-btn" onclick="handleMapAction('Heal')">ä¼‘æ¯ (æ¢å¾© HP)</button>
    </div>

    <div id="decision-menu">
        <button id="btn-decision-yes" class="decision-btn decision-btn-yes" onclick="handleRingDecision('YES')">ğŸ’ æ›ä¸Š/å‡ç´šæ–°æˆ’æŒ‡</button>
        <button id="btn-decision-no" class="decision-btn decision-btn-no" onclick="handleRingDecision('NO')">ğŸš« ä¿ç•™èˆŠæˆ’æŒ‡</button>
    </div>

    <div id="message-log">
        <div class="log-msg">å‹‡è€…è¸ä¸Šäº†å†’éšªçš„æ—…é€”...</div>
    </div>

    <div id="equipment-display">
        **âš™ï¸ è£å‚™æ¬„**<br>
        æ­¦: <span id="eq-weapon">å¾’æ‰‹</span> |
        ç›¾: <span id="eq-shield">ç„¡</span> |
        æˆ’: <span id="eq-ring">ç„¡</span><br>
        ç²¾ç·´ç­‰ç´šï¼šæ­¦å™¨ç²¾ç·´ +<span id="weapon-refine-level">0</span> (ç´ æ <span id="weapon-materials">0</span>/5)ï¼›
        ç›¾ç‰Œç²¾ç·´ +<span id="shield-refine-level">0</span> (ç´ æ <span id="shield-materials">0</span>/5)
        <hr style="border-top: 1px solid #ccc; margin: 5px 0;">
        **ğŸ›¡ï¸ è£å‚™å±¬æ€§**<br>
        æ”»: <span id="eq-detail-weapon">æ”»æ“ŠåŠ› +0</span> |
        é˜²: <span id="eq-detail-shield">é˜²ç¦¦åŠ› +0</span><br>
        æˆ’: <span id="eq-detail-ring">ç‰¹æ•ˆï¼šç„¡ (Lv.0)</span><br>
        æ­¦å™¨è©æ¢: <span id="eq-weapon-affix">ç„¡</span><br>
        ç›¾ç‰Œè©æ¢: <span id="eq-shield-affix">ç„¡</span>
    </div>
</div>

<div id="game-manual">
    <h2>ğŸ“– éŠæˆ²èªªæ˜èˆ‡æˆ°é¬¥è¦å‰‡</h2>

    <h3>âš”ï¸ æˆ°é¬¥ç³»çµ±ï¼šä¸‰ç¨®æ‹›å¼ + å…‹åˆ¶é—œä¿‚</h3>
    <ul>
        <li>æ‹›å¼ï¼š
            <ul>
                <li>âš”ï¸ <b>ç æ“Šï¼ˆç‰©ç†ï¼‰</b>ï¼šåƒ ATKï¼Œå‚·å®³ = ATK âˆ’ æ€ªç‰© DEFï¼Œæœƒè¢«æ€ªç‰©é–ƒé¿å½±éŸ¿ã€‚</li>
                <li>ğŸŒ  <b>é­”æ³•æ”»æ“Š</b>ï¼šåƒ MATKï¼Œå‚·å®³ = é­”æ”» âˆ’ æ€ªç‰© MDEFï¼Œ<b>çµ•å°å‘½ä¸­ï¼Œä¸æœƒè¢«é–ƒé¿</b>ã€‚</li>
                <li>ğŸ›¡ï¸ <b>ç›¾æ“Š</b>ï¼šå‚·å®³ = ä½ ç›®å‰çš„ <b>DEF æ•¸å€¼</b>ï¼Œ<b>å®Œå…¨ç„¡è¦–æ€ªç‰©æ‰€æœ‰é˜²ç¦¦ (DEF/MDEF)</b>ï¼Œä½†æœƒè¢«æ€ªç‰©é–ƒé¿ã€‚</li>
            </ul>
        </li>
        <li><b>å…‹åˆ¶é—œä¿‚ï¼š</b> âš”ï¸ > é­”æ³• > ç›¾æ“Š > âš”ï¸ã€‚</li>
        <li><b>å…‹åˆ¶ï¼š</b> å‹æ–¹é€ æˆå‚·å®³ï¼Œè¢«å…‹åˆ¶æ–¹è©²å›åˆå®Œå…¨å¤±æ•ˆã€‚</li>
        <li><b>å¹³æ‰‹ï¼š</b> å‡ºåŒä¸€æ‹›ï¼Œä¾ã€Œå¹³æ‰‹å‹ç‡ã€åˆ¤å®šæ˜¯æˆ‘æ–¹æ‰“é‚„æ˜¯æ€ªæ‰“ã€‚</li>
        <li><b>ç›¾æ“Šå‚·å®³ï¼š</b> ä¸çœ‹ä»»ä½•é˜²ç¦¦ï¼Œç›´æ¥åƒ DEFï¼Œé˜²ç¦¦å †è¶Šé«˜ï¼Œç›¾æ“Šè¶Šç—›ã€‚</li>
    </ul>

    <h3>ğŸ˜ˆ æ€ªç‰©èˆ‡å¼±é»ï¼ˆåªæœƒé€²å ´è¬›ä¸€å¥å¹¹è©±ï¼‰</h3>
    <ul>
        <li><b>å“¥å¸ƒæ—ï¼š</b>ã€Œäººä¸æ˜¯æˆ‘æ®ºçš„ï¼Œæˆ‘åªæ˜¯è² è²¬æ”¶å±ã€‚ã€</li>
        <li><b>éª·é«å…µï¼š</b>ã€Œæˆ‘å…ˆèªªï¼Œå‹å¥ä¿æ²’å¹«æˆ‘ä¿ã€‚ã€</li>
        <li><b>é‡ç‹¼ï¼š</b>ã€Œæˆ‘åªå’¬åŠ ç­çš„äººã€‚ã€</li>
        <li><b>çŸ³é ­äººï¼š</b>ã€Œæˆ‘é˜²ç¦¦è¶…é«˜ï¼Œæ”»æ“Šè¶…ä½ï¼Œè·Ÿæˆ‘è–ªæ°´ä¸€æ¨£ã€‚ã€</li>
        <li><b>è™è ï¼š</b>ã€Œæˆ‘ä¸æ˜¯å¸è¡€é¬¼ï¼Œæˆ‘åªæ˜¯æƒ³å–ç„¡ç³–ã€‚ã€</li>
    </ul>

    <h3>ğŸ“Š èƒ½åŠ›å€¼èªªæ˜</h3>
    <ul>
        <li><b>ATKï¼š</b> å½±éŸ¿ âš”ï¸ ç æ“Šçš„ç‰©ç†å‚·å®³ã€‚</li>
        <li><b>DEFï¼š</b> æ¸›å°‘æ€ªç‰©ç‰©ç†å‚·å®³ï¼Œä¸¦æ±ºå®šï¼š
            <ul>
                <li>ğŸ›¡ï¸ ç›¾æ“Šå‚·å®³ = DEFï¼ˆç„¡è¦–é˜²ç¦¦ï¼‰ã€‚</li>
            </ul>
        </li>
        <li><b>MATKï¼š</b> é­”æ”»ï¼Œç”¨ä¾†è¨ˆç®—é­”æ³•æ”»æ“Šå‚·å®³èˆ‡éƒ¨åˆ†å›å¾©é‡ã€è€ç·´è€å±è‚¡çš„é­”æ³•è¿½å‚·ã€‚</li>
        <li><b>é–ƒé¿ï¼š</b> æœ‰æ©Ÿç‡å®Œå…¨é–ƒæ‰æ•µæ–¹æ”»æ“Šï¼Œ<b>ä¸Šé™ 75%</b>ã€‚</li>
        <li><b>å¹³æ‰‹å‹ç‡ï¼š</b> é›™æ–¹å‡ºåŒæ‹›æ™‚ï¼Œæˆ‘æ–¹è¢«åˆ¤å®šç‚ºã€Œè´ã€çš„æ©Ÿç‡ã€‚</li>
        <li><b>çˆ†æ“Šï¼š</b> ç æ“Šæœ‰æ©Ÿæœƒçˆ†æ“Šï¼ˆ2 å€å‚·å®³ï¼‰ï¼Œç›¾æ“Šä¸æœƒçˆ†æ“Šã€‚</li>
    </ul>

    <h3>ğŸ’ æˆ’æŒ‡èƒ½åŠ›ï¼ˆé‡é»ï¼šæ•æ·æŒ‡ç’° & ç‹‚æˆ°è·ï¼‰</h3>
    <ul>
        <li><b>æ•æ·æŒ‡ç’° (DODGE)</b>
            <ul>
                <li>æé«˜å¤§é‡é–ƒé¿ç‡ã€‚</li>
                <li>ç•¶ä½ çš„ã€Œå¯¦éš›é–ƒé¿ã€è¶…é 75% æ™‚ï¼Œå¤šå‡ºä¾†çš„éƒ¨åˆ†æœƒè®Šæˆ<b>è¿½æ“Šæ©Ÿç‡</b>ï¼ˆä¾‹å¦‚ï¼šé¡¯ç¤º 75%ï¼Œå¯¦éš› 85%ï¼Œå¤šå‡º 10% å°±æ˜¯è¿½æ“Šç‡ 10%ï¼‰ã€‚</li>
                <li>æˆåŠŸé–ƒé¿æ€ªç‰©æ”»æ“Šæ™‚ï¼Œæœƒ<b>ç«‹åˆ»æ™®æ”»åæ“Šä¸€æ¬¡</b>ã€‚</li>
            </ul>
        </li>
        <li><b>ç‹‚æˆ°å£«æŒ‡ç’° (BERSERKER)</b>
            <ul>
                <li>çŠ§ç‰² DEF / HP æ›å¤§é‡ ATKã€‚</li>
                <li>ç‰©ç†æ”»æ“Šæœ‰æ©Ÿæœƒå¤šæ®µæ”»æ“Šï¼Œæˆ°é¬¥è¨Šæ¯æœƒé¡¯ç¤ºã€Œç¬¬1æ“Šã€ç¬¬2æ“Šâ€¦ã€èˆ‡æ¯ä¸€æ“Šå‚·å®³ï¼ˆå«æš´æ“Šèˆ‡è€å±è‚¡é­”å‚·ï¼‰ï¼Œæœ€å¾ŒåŠ ç¸½ã€‚</li>
            </ul>
        </li>
        <li>å…¶é¤˜æˆ’æŒ‡ï¼ˆå¹¸é‹ã€ç”Ÿå‘½ã€é­”å°ã€å¹³è¡¡ï¼‰å»¶çºŒåŸæœ¬æ•ˆæœã€‚</li>
    </ul>

    <h3>ğŸ’ è£å‚™ç¨€æœ‰åº¦èˆ‡æ‰è½è§£é–</h3>
    <ul>
        <li><span class="Rarity-Normal">ç°è‰² Normal</span></li>
        <li><span class="Rarity-Magic">ç¶ è‰² Magic</span></li>
        <li><span class="Rarity-Rare">è—è‰² Rare</span></li>
        <li><span class="Rarity-Epic">ç´«è‰² Epic</span></li>
        <li><span class="Rarity-Legendary">æ©˜è‰² Legendary</span></li>
        <li><span class="Rarity-Mythic">ç´…è‰² Mythic</span></li>
    </ul>
    <p>æ‰è½éšæ®µï¼ˆæ­¦å™¨ / ç›¾ç‰Œï¼‰ï¼š</p>
    <ul>
        <li><b>æ‰“ç¬¬ä¸€éš» Boss ä¹‹å‰ï¼š</b> åªæœƒæ‰ ç´« / è— / ç¶  / ç°ã€‚</li>
        <li><b>æ‰“æ­»ç¬¬ä¸€éš» Boss ä¹‹å¾Œï¼š</b> åŠ å…¥ <span class="Rarity-Legendary">æ©˜æ­¦ã€æ©˜ç›¾</span>ã€‚</li>
        <li><b>æ‰“æ­»ç¬¬äºŒéš» Boss ä¹‹å¾Œï¼š</b> å†åŠ å…¥ <span class="Rarity-Mythic">ç´…æ­¦ã€ç´…ç›¾</span>ã€‚</li>
    </ul>

    <h3>ğŸ§² æ­¦å™¨ / ç›¾ç‰Œè©æ¢èªªæ˜ï¼ˆå„ 12 ç¨®ï¼‰</h3>
        <p><b>æ­¦å™¨è©æ¢</b>ï¼ˆæ‹¬è™Ÿå…§ç‚ºå¯¦éš›æ•ˆæœï¼‰ï¼š</p>
        <ul>
            <li>
                <b>å·æ‘¸ä¸€æŠŠ</b>ï¼šç‰©ç†æ”»æ“Šæ™‚ï¼Œæœ‰ <b>20%</b> æ©Ÿç‡å¤šæ‰“ä¸€æ“Šã€‚
            </li>
            <li>
                <b>çŸ¥è­˜å°±æ˜¯åŠ›é‡</b>ï¼šå¸¶ä¸Šä¸€æœ¬æ›¸ï¼Œæé«˜ç‰©ç†æ”»æ“ŠåŠ›ï¼Œéš¨æ™‚å¯ä»¥æ•²æ‰“æ•µäººçš„é ­ï¼Œæœ€çµ‚ç‰©ç† ATK ç´„ +12%ã€‚
            </li>
            <li>
                <b>ç‡ƒç‡’å°å®‡å®™ğŸŒ€</b>ï¼šå‹‡è€…é­”æ³•æ”»æ“Šï¼ˆMATKï¼‰<b>+10%</b>ã€‚
            </li>
            <li>
                <b>ç¥é€Ÿè„«è¡£</b>ï¼šç æ“Šæ™‚è¨ˆç®—å‚·å®³æ™‚ï¼Œç„¡è¦–æ•µäºº<b>30%</b>é˜²ç¦¦åŠ›ã€‚
            </li>
            <li>
                <b>æ„›åƒä¸è¾£çš„(Blood)</b>ï¼šæœ¬æ¬¡ç‰©ç†æ”»æ“Šé€ æˆçš„ã€Œç¸½å‚·å®³ã€çš„ <b>20%</b> æœƒè½‰æˆè‡ªæˆ‘å›è¡€ï¼ˆè‡³å°‘ 1 é»ï¼‰ã€‚
            </li>
            <li>
                <b>å†åŠ æŠŠå‹</b>ï¼šå¹³æ‰‹æ™‚ï¼Œå‹‡è€…é¡å¤–ç²å¾— +7% åˆ¤å®šç²å‹ç‡ï¼ˆå¯èˆ‡æˆ’æŒ‡ã€ç›¾ç‰ŒåŠ æˆç–ŠåŠ ï¼Œä¸Šé™ 100%ï¼‰ã€‚

            </li>
            <li>
                <b>å¡ä½ å·´æŒ</b>ï¼šåŸºæœ¬æš´æ“Šç‡ +<b>5%</b>ï¼ˆç”± 5% â†’ 10%ï¼‰ã€‚
            </li>
            <li>
                <b>6é»äº†æˆ‘å…ˆä¸‹ç­äº†</b>ï¼šé–ƒé¿ç‡ +<b>3%</b>ã€‚
            </li>
            <li>
                <b>åŠ ç­å‹ç¢Œå‘½</b>ï¼šç•¶ HP ä½æ–¼æœ€å¤§å€¼çš„ <b>30%</b> æ™‚ï¼š
                ç‰©æ”» +<b>15%</b>ï¼Œæš´æ“Šç‡é¡å¤– +<b>10%</b>ã€‚
            </li>
            <li>
                <b>è€ç·´è€å±è‚¡</b>ï¼šæ¯ä¸€æ“Šç æ“Šé¡å¤–é™„åŠ ç›¸ç•¶æ–¼å‹‡è€…é­”æ”» <b>30%</b> çš„é­”æ³•å‚·å®³ã€‚
            </li>
            <li>
                <b>ç«å¤§äº‚ç </b>ï¼šç‰©ç†æ”»æ“Šæ™‚ï¼Œæœ‰ <b>5%</b> æ©Ÿç‡ç›´æ¥è®Šæˆã€Œè‡³å°‘ã€<b>3 é€£æ“Š</b>ã€‚
            </li>
            <li>
                <b>æ‰“äº†åˆæ‰“</b>ï¼šåŒä¸€å›åˆå…§çš„é€£æ“Šæœƒè¶Šæ‰“è¶Šç—›ï¼š
                ç¬¬ 2 æ“Šå‚·å®³ +<b>15%</b>ï¼Œç¬¬ 3 æ“Š +<b>30%</b>ï¼Œç¬¬ 4 æ“Šä»¥ä¸Šä¾åºå† +15% ç–Šä¸Šå»ã€‚
            </li>
        </ul>
        
        <p><b>ç›¾ç‰Œè©æ¢</b>ï¼ˆæœ‰ã€Œè©ä¸ŠåŠ è©ã€éˆï¼‰ï¼š</p>
        <ul>
            <li>
                <b>æˆ‘æ“‹~ğŸ›¡ï¸</b>ï¼šå—åˆ°æ”»æ“Šæ™‚ï¼Œæœ‰ <b>20%</b> æ©Ÿç‡æœ¬æ¬¡å‚·å®³æ¸›åŠï¼Œ
                ä¸¦å¯è§¸ç™¼å¾ŒçºŒã€Œæˆ‘å†é ‚~ğŸ’¥ / æˆ‘å†ç ~ğŸ”ªã€ç­‰æ•ˆæœã€‚
            </li>
            <li>
                <b>é­”æ³•èƒ¸ç½©</b>ï¼šæ–½æ”¾é­”æ³•æˆ–ç›¾æ“Šæ™‚ï¼Œæœ‰ <b>20%</b> æ©Ÿç‡ç²å¾—
                <b>3 å›åˆ</b>ã€Œå—åˆ°å‚·å®³æ¸›åŠã€çš„é­”æ³•è­·ç›¾ã€‚
            </li>
            <li>
                <b>åšè‡‰çš®</b>ï¼šé˜²ç¦¦åŠ›ï¼ˆDEFï¼‰<b>+10%</b>ã€‚
            </li>
            <li>
                <b>è±¹å­é€šæ®º</b>ï¼šå¹³æ‰‹æ™‚å‹‡è€…ç²å‹çš„æ©Ÿç‡ +<b>5%</b>ã€‚
            </li>
            <li>
                <b>æ€éº¼åˆºåˆºçš„</b>ï¼šå—åˆ°å‚·å®³æ™‚ï¼Œåå½ˆæœ¬æ¬¡å¯¦éš›å‚·å®³çš„ <b>20%</b>
                çµ¦æ•µäººï¼ˆè‡³å°‘ 1 é»ï¼‰ã€‚
            </li>
            <li>
                <b>æ­£åœ¨å¿™åˆ¥çš„æ¡ˆå­</b>ï¼šé–ƒé¿ç‡ +<b>5%</b>ã€‚
            </li>
            <li>
                <b>ç™¢ç™¢æ»´</b>ï¼šè¢« Boss æ”»æ“Šæ™‚ï¼Œæ‰¿å—çš„æœ€çµ‚å‚·å®³ -<b>10%</b>ã€‚
            </li>
            <li>
                <b>ä¸å¤ªç—›</b>ï¼šè¢«ä¸€èˆ¬å°æ€ªæ”»æ“Šæ™‚ï¼Œæ‰¿å—çš„æœ€çµ‚å‚·å®³ -<b>10%</b>ã€‚
            </li>
            <li>
                <b>åƒå€‹éºµåŒ…å…ˆ</b>ï¼šæ¯å ´æˆ°é¬¥é–‹å§‹æ™‚ç²å¾—æŒçºŒå›å¾©æ•ˆæœï¼Œ
                å¤§ç´„ <b>3 å›åˆ</b>ã€æ¯å›åˆå›å¾©ç´„æœ€å¤§ HP çš„ <b>3%</b>ï¼ˆè‡³å°‘ 2 é» HPï¼‰ã€‚
            </li>
            <li>
                <b>YA~æ’¿åˆ°åå¡ŠéŒ¢</b>ï¼šè£å‚™è¢«åˆ†è§£æˆç´ ææ™‚ï¼Œè‹¥åŸæœ¬æœƒå¾—åˆ°ç´ æï¼Œ
                æœ‰ <b>30%</b> æ©Ÿç‡é¡å¤–å¤šå‡º <b>1</b> ä»½ç´ æã€‚
            </li>
            <li>
                <b>æˆ‘å†é ‚~ğŸ’¥</b>ï¼šéœ€è¦å…ˆæœ‰ã€Œæˆ‘æ“‹~ğŸ›¡ï¸ã€ã€‚
                ç•¶ã€Œæˆ‘æ“‹~ğŸ›¡ï¸ã€æ ¼æª”æˆåŠŸæ™‚ï¼Œæœƒå†è¿½åŠ ä¸€æ¬¡ä»¥ã€Œç›®å‰é˜²ç¦¦åŠ›ã€ç‚ºåŸºç¤çš„ç›¾æ“Šæ”»æ“Šã€‚
            </li>
            <li>
                <b>æˆ‘å†ç ~ğŸ”ª</b>ï¼šéœ€è¦å…ˆæœ‰ã€Œæˆ‘æ“‹~ğŸ›¡ï¸ã€ã€‚
                ç•¶ã€Œæˆ‘æ“‹~ğŸ›¡ï¸ã€æ ¼æª”æˆåŠŸæ™‚ï¼Œæœƒå†è£œä¸Šä¸€åˆ€æ™®é€šç æ“Šï¼Œ
                æœƒåƒåˆ°æ‰€æœ‰ç‰©ç†ç›¸é—œæ•ˆæœï¼ˆæš´æ“Šã€å¤šæ®µæ”»æ“Šã€æ‰“äº†åˆæ‰“ç­‰ï¼‰ã€‚
            </li>
        </ul>
        <p>
            ã€Œæˆ‘å†é ‚~ğŸ’¥ã€ã€ã€Œæˆ‘å†ç ~ğŸ”ªã€åªæœƒå‡ºç¾åœ¨å·²ç¶“æ“æœ‰ã€Œæˆ‘æ“‹~ğŸ›¡ï¸ã€çš„ç›¾ç‰Œä¸Šã€‚<br>
            ç™¼å‹•æ™‚æ©Ÿèˆ‡å¤šæ®µå‚·å®³ç´°ç¯€æœƒåœ¨æˆ°é¬¥ Log ä¸­é€æ¢é¡¯ç¤ºã€‚
        </p>


    <h3>ğŸ›  ç²¾ç·´ç³»çµ±ï¼ˆ+3 è§£é–è©æ¢ï¼‰</h3>
    <ul>
        <li><b>æ­¦å™¨ç²¾ç·´ç¶åœ¨è§’è‰²</b>ï¼šæ›æ­¦å™¨æ™‚ï¼Œç²¾ç·´ç­‰ç´šèˆ‡ç²¾ç·´è©æ¢éƒ½æœƒè·Ÿè‘—æ–°æ­¦å™¨èµ°ã€‚</li>
        <li><b>ç›¾ç‰Œç²¾ç·´ç¶ç›¾æœ¬èº«</b>ï¼šæ›ç›¾å°±æ›æ‰ã€‚</li>
        <li><b>æ¯ +3 ç²¾ç·´ï¼ˆ+3 / +6 / +9 ...ï¼‰å°±å¢åŠ ä¸€æ¢è©æ¢ã€‚</b></li>
        <li>åˆ†è§£è£å‚™å¾—åˆ°ç´ æï¼Œæ¯ 5 é»ç´ æè‡ªå‹•ç²¾ç·´ä¸€æ¬¡ï¼Œç²¾ç·´ä¸æœƒå¤±æ•—ã€‚</li>
    </ul>
</div>

<script>
    let gameState = 'MAP';
    let totalTurnCount = 0;   // ç¸½å›åˆæ•¸ï¼ˆæ¯æ¬¡è¡Œå‹•+1ï¼Œç ´é—œæ’åºç”¨ï¼‰

    // ===== ç¨±è™Ÿæ–‡å­—åº« =====
    // ä½ ä¹‹å¾Œæƒ³è¦ 30 å€‹å°±ä¸€ç›´åŠ 
    const TITLE_A = [
      'å‰å¤§çš„','æš´èµ°çš„','ç¥ç§˜çš„','ç„¡æƒ…çš„','ç†±è¡€çš„',
      'æ‚ å“‰çš„','å‚³èªªä¸­çš„','å­¤ç¨çš„','å‹‡æ•¢çš„','ä½›ç³»çš„'
    ];
    const TITLE_B = [
      'å¸¥æ°£','é™°æ²‰','æš´æ€’','å†·éœ','é‚Šç·£',
      'æ—©ç¡','æ‰“å¯¶ç‹‚','éæ´²','æ­æ´²','é–‹å¤–æ›'
    ];
    const TITLE_C = [
      'è€é—†','å‹‡è€…','ä¸Šç­æ—','å»¢äºº','é­”ç‹',
      'èœé³¥','æ‘¸é­šç‹','çˆ†è‚è€…','æ—…äºº','æ›ç¶²è€…'
    ];

    
    const HERO_MAX_HP_START = 20;
    const MAX_LEVEL = 25;
    const HP_PER_LEVEL = 5;

    const RARITY_ORDER = ['Normal', 'Magic', 'Rare', 'Epic', 'Legendary', 'Mythic'];
    const RARITY_MATERIAL_VALUE = {
        Normal: 0, Magic: 1, Rare: 2, Epic: 3, Legendary: 4, Mythic: 5
    };

    const MAGIC_REFINE_BONUS = {
        Normal: 1, Magic: 3, Rare: 5, Epic: 8, Legendary: 12, Mythic: 16
    };
    const WEAPON_MATERIAL_PER_REFINE = 5;
    const SHIELD_MATERIAL_PER_REFINE = 5;
    let weaponMaterials = 0;
    let shieldMaterials = 0;

    const MAGIC_RING_MAGIC_RATE = [0, 0.25, 0.50, 0.75, 1.00];
    const CRIT_RING_MAGIC_RATE  = [0, 0.10, 0.20, 0.30, 0.40];

    const BERSERKER_MULTI_HIT_CHANCE = [0, 0.15, 0.25, 0.35, 0.45];
    const BERSERKER_THIRD_HIT_CHANCE = [0, 0.0, 0.10, 0.20, 0.25];

    let hero = {
        name: 'ç„¡åè‹±é›„',
        hp: HERO_MAX_HP_START,
        maxHp: HERO_MAX_HP_START,
        level: 1,
        highestLevel: 1,
        exp: 0,
        title: "",   // â˜…â˜… åˆå§‹åŒ–ç¨±è™Ÿ â†’ ä¸æœƒæ²¿ç”¨ä¸Šæ¬¡è¨˜éŒ„
        expToNextLevel: 10,
        baseAttack: 15,
        baseDefense: 10,
        baseDodge: 5,       // èµ·å§‹é–ƒé¿ 5%
        baseTieWinRate: 30,
        baseMagicAtk: 20,
        equipment: {
            WEAPON: { name: "å¾’æ‰‹", power: 0, rarity: 'Normal', affixes: [] },
            SHIELD: { name: "ç„¡", power: 0, rarity: 'Normal', refine: 0, affixes: [], refineSlots: 0 },
            RING: { name: "ç„¡", ability: null, tier: 0, rarity: 'Normal' }
        },
        berserkerBonus: 0,
        berserkerPenalty: 0,
        healRingDefBonus: 0,
        currentAttack: 0,
        currentDefense: 0,
        currentDodge: 0,        // é¡¯ç¤ºç”¨ (æœ€å¤š 75%)
        dodgeOverflow: 0,       // æº¢å‡ºçš„è¿½æ“Šæ©Ÿç‡ï¼ˆ%ï¼‰
        currentTieWinRate: 0,
        currentMagicAtk: 0,
        magicGuardTurns: 0,
        burnTurns: 0,
        burnDamage: 0,
        defDownTurns: 0,
        defDownRate: 0,
        weaponRefineLevel: 0,
        weaponRefineSlots: 0,
        weaponRefineAffixes: [],
        // å†’éšªäº‹ä»¶ buff
        buffDamageUpTurns: 0,
        buffDamageUpRate: 0,
        regenTurns: 0,
        regenAmount: 0
    };

        //åˆå§‹åŒ–ç¨±è™Ÿé¸å–®
    function initTitleSelectBox() {
        const selA = document.getElementById('titleA');
        const selB = document.getElementById('titleB');
        const selC = document.getElementById('titleC');
    
        // å…ˆå¡ä¸€å€‹ã€Œä¸é¸ã€é¸é …
        function fillSelect(sel, arr) {
            sel.innerHTML = '';
            const optEmpty = document.createElement('option');
            optEmpty.value = '';
            optEmpty.textContent = 'ï¼ˆéš¨æ©Ÿï¼‰';
            sel.appendChild(optEmpty);
    
            arr.forEach(txt => {
                const opt = document.createElement('option');
                opt.value = txt;
                opt.textContent = txt;
                sel.appendChild(opt);
            });
        }
    
        fillSelect(selA, TITLE_A);
        fillSelect(selB, TITLE_B);
        fillSelect(selC, TITLE_C);
    }


    
    function getShieldRefineLevel() {
        return hero.equipment.SHIELD.refine || 0;
    }

    let currentEnemy = null;
    let bossLevel = 1;
    let newLoot = null;

    let healCooldown = 30000;
    let lastHealTime = 0;
    let healCooldownTimer = null;
    let turnCount = 0;

    const CLASH_RULES = {
        'âš”ï¸': 'ğŸŒ ',
        'ğŸŒ ': 'ğŸ›¡ï¸',
        'ğŸ›¡ï¸': 'âš”ï¸'
    };

    const RING_ABILITIES = [
        {
            id: 'CRIT',
            name: 'å¹¸é‹æˆ’æŒ‡',
            desc: 'æé«˜æš´æ“Šæ©Ÿç‡ï¼Œç•¥å¾®æå‡é­”æ³•ç›¸é—œå‚·å®³',
            effect: () => {}
        },
        {
            id: 'HEAL',
            name: 'ç”Ÿå‘½æˆ’æŒ‡',
            desc: 'æ ¼æ“‹æˆåŠŸæˆ–ç›¾æ“Šé€ æˆå‚·å®³æ™‚å›å¾© HPï¼Œå›å¾©é‡ä¾ DEF è€Œå®šï¼Œä¸¦å°å¹…æå‡ DEF',
            effect: () => {}
        },
        {
            id: 'DODGE',
            name: 'æ•æ·æŒ‡ç’°',
            desc: 'æé«˜é–ƒé¿ï¼Œé–ƒé¿è¶…é 75% çš„éƒ¨åˆ†æœƒè®Šæˆè¿½æ“Šæ©Ÿç‡ï¼ŒæˆåŠŸé–ƒé¿æ™‚é‚„æœƒæ™®æ”»åæ“Šä¸€æ¬¡',
            effect: (hero) => 0.10 + hero.equipment.RING.tier * 0.08
        },
        {
            id: 'MAGIC',
            name: 'é­”å°æŒ‡ç’°',
            desc: 'å¤§å¹…æé«˜é­”æ³•ç›¸é—œå‚·å®³',
            effect: (tier) => MAGIC_RING_MAGIC_RATE[tier] || 0
        },
        {
            id: 'BERSERKER',
            name: 'ç‹‚æˆ°å£«æŒ‡ç’°',
            desc: 'çŠ§ç‰²æœ€å¤§HPæ›å–å¤§é‡ATKï¼Œç‰©ç†æ”»æ“Šæœ‰æ©Ÿæœƒå¤šæ®µæ”»æ“Šä¸¦ç•¥å¢çˆ†æ“Šç‡',
            effect: (tier) => {
                const ratios = [0, 0.30, 0.40, 0.50, 0.60];
                return ratios[tier] || 0;
            }
        },
        {
            id: 'BALANCE',
            name: 'å¹³è¡¡æŒ‡ç’°',
            desc: 'æå‡å¹³æ‰‹æ™‚å‹‡è€…ç²å‹çš„æ©Ÿç‡',
            effect: (tier) => 10 + tier * 10
        },
        { id: 'NONE', name: 'ç„¡', desc: 'ç„¡' }
    ];

    // === æ­¦å™¨è©æ¢ï¼ˆ12 å€‹ï¼‰ ===
    const WEAPON_AFFIX_POOL = [
        { id: 'W_EXTRA_HIT', name: 'å·æ‘¸ä¸€æŠŠ', desc: 'ç‰©ç†æ”»æ“Šæ™‚æœ‰ 20% æ©Ÿç‡å¤šæ‰“ä¸€æ“Šã€‚', prereq: null },
        { id: 'W_ATK_UP',    name: 'çŸ¥è­˜å°±æ˜¯åŠ›é‡', desc: 'å¸¶è‘—ä¸€æœ¬æ›¸æé«˜å°‘é‡ç‰©ç†æ”»æ“ŠåŠ›ï¼Œéš¨æ™‚å¯ä»¥ç”¨æ›¸æœ¬æ•²æ‰“æ•µäººçš„é ­ã€‚', prereq: null },
        { id: 'W_MAGIC_UP',  name: 'ç‡ƒç‡’å°å®‡å®™ğŸŒ€', desc: 'æé«˜å°‘é‡é­”æ³•æ”»æ“ŠåŠ›ã€‚', prereq: null },
        { id: 'W_ARMOR_PEN', name: 'ç¥é€Ÿè„«è¡£', desc: 'ç æ“Šæ™‚ç„¡è¦–éƒ¨åˆ†æ•µäººé˜²ç¦¦ã€‚', prereq: null },
        { id: 'W_LIFESTEAL', name: 'æ„›åƒä¸è¾£çš„(Blood)', desc: 'ç‰©ç†å‚·å®³çš„ä¸€éƒ¨åˆ†æœƒè½‰ç‚ºå›è¡€ã€‚', prereq: null },
        { id: 'W_BALANCE',   name: 'å†åŠ æŠŠå‹', desc: 'å¹³æ‰‹æ™‚ç¨å¾®æé«˜æˆ‘æ–¹åˆ¤å®šå‹ç‡ã€‚', prereq: null },
        { id: 'W_CRIT_UP',   name: 'å¡ä½ å·´æŒ', desc: 'æé«˜ç æ“Šçˆ†æ“Šç‡ã€‚', prereq: null },
        { id: 'W_DODGE_UP',  name: '6é»äº†æˆ‘å…ˆä¸‹ç­äº†', desc: 'æé«˜å°‘é‡é–ƒé¿ç‡ã€‚', prereq: null },
        { id: 'W_BRAVE',     name: 'åŠ ç­å‹ç¢Œå‘½', desc: 'ç•¶ HP ä½æ–¼ 30% æ™‚ï¼Œç‰©æ”»èˆ‡çˆ†æ“Šç‡æå‡ã€‚', prereq: null },
        { id: 'W_VETERAN',   name: 'è€ç·´è€å±è‚¡', desc: 'ç æ“Šæ™‚é¡å¤–é€ æˆä¾é­”æ”»æ¯”ä¾‹çš„é­”æ³•å‚·å®³ã€‚', prereq: null },
        { id: 'W_RAGE',      name: 'ç«å¤§äº‚ç ', desc: 'ç‰©ç†æ”»æ“Šæœ‰å°æ©Ÿç‡ç›´æ¥è®Šæˆä¸‰é€£æ“Šã€‚', prereq: null },
        { id: 'W_CHAIN',     name: 'æ‰“äº†åˆæ‰“', desc: 'åŒä¸€å›åˆé€£æ“Šæ™‚ï¼Œç¬¬äºŒæ“Šèµ·å‚·å®³é€æ“Šæé«˜ã€‚', prereq: null }
    ];

    // === ç›¾ç‰Œè©æ¢ï¼ˆ12 å€‹ï¼Œå«ã€Œè©ä¸ŠåŠ è©ã€ï¼‰ ===
    const SHIELD_AFFIX_POOL = [
        { id: 'S_BLOCK',        name: 'æˆ‘æ“‹~ğŸ›¡ï¸',       desc: 'å—åˆ°å‚·å®³æ™‚æœ‰ 20% æ©Ÿç‡æ¸›å°‘ 50% å‚·å®³ï¼Œè§¸ç™¼å¾ŒçºŒæ“‹ç³»æ•ˆæœã€‚', prereq: null },
        { id: 'S_MAGIC_GUARD',  name: 'é­”æ³•èƒ¸ç½©',     desc: 'æ–½æ”¾é­”æ³• / ç›¾æ“Šæ™‚æœ‰ 20% æ©Ÿç‡ç²å¾— 3 å›åˆ 50% æ¸›å‚·æ•ˆæœã€‚', prereq: null },
        { id: 'S_DEF_UP',       name: 'åšè‡‰çš®',       desc: 'æé«˜å°‘é‡é˜²ç¦¦åŠ›ã€‚', prereq: null },
        { id: 'S_TIE_UP',       name: 'è±¹å­é€šæ®º',     desc: 'ç¨å¾®æé«˜å¹³æ‰‹å‹ç‡ã€‚', prereq: null },
        { id: 'S_REFLECT',      name: 'æ€éº¼åˆºåˆºçš„',     desc: 'å—åˆ°å‚·å®³æ™‚åå½ˆéƒ¨åˆ†å‚·å®³çµ¦æ•µäººã€‚', prereq: null },
        { id: 'S_DODGE_UP',     name: 'æ­£åœ¨å¿™åˆ¥çš„æ¡ˆå­',     desc: 'æé«˜å°‘é‡é–ƒé¿ç‡ã€‚', prereq: null },
        { id: 'S_BOSS_GUARD',   name: 'ç™¢ç™¢æ»´',     desc: 'å° Boss å—åˆ°çš„å‚·å®³ç•¥å¾®é™ä½ã€‚', prereq: null },
        { id: 'S_SMALL_GUARD',  name: 'ä¸å¤ªç—›',     desc: 'å°ä¸€èˆ¬å°æ€ªå—åˆ°çš„å‚·å®³ç•¥å¾®é™ä½ã€‚', prereq: null },
        { id: 'S_REGEN',        name: 'åƒå€‹éºµåŒ…å…ˆ',     desc: 'æ¯å ´æˆ°é¬¥é–‹å§‹æ™‚ç²å¾—å¹¾å›åˆçš„å°é‡å›è¡€ã€‚', prereq: null },
        { id: 'S_MAT_BOOST',    name: 'YA~æ’¿åˆ°åå¡ŠéŒ¢',     desc: 'è£å‚™è¢«åˆ†è§£æ™‚ï¼Œå¶çˆ¾å¤šæ‰ä¸€é»ç´ æã€‚', prereq: null },
        { id: 'S_BLOCK_STRIKE', name: 'æˆ‘å†é ‚~ğŸ’¥',     desc: 'éœ€è¦ã€Œæˆ‘æ“‹~ğŸ›¡ï¸ã€ï¼Œæ ¼æª”æˆåŠŸæ™‚å†è¿½åŠ ä¸€æ¬¡ç›¾æ“Šã€‚', prereq: 'S_BLOCK' },
        { id: 'S_BLOCK_CRIT',   name: 'æˆ‘å†ç ~ğŸ”ª',     desc: 'éœ€è¦ã€Œæˆ‘æ“‹~ğŸ›¡ï¸ã€ï¼Œæ ¼æª”æˆåŠŸæ™‚å†è£œä¸Šä¸€åˆ€ç æ“Šã€‚', prereq: 'S_BLOCK' }
    ];

    function findAffix(pool, id) {
        return pool.find(a => a.id === id);
    }

    function getAllWeaponAffixSet() {
        const weapon = hero.equipment.WEAPON || {};
        const set = new Set();
        (weapon.affixes || []).forEach(id => set.add(id));
        (hero.weaponRefineAffixes || []).forEach(id => set.add(id));
        return set;
    }

    function addRandomAffixToWeaponRefine() {
        const existing = new Set(hero.weaponRefineAffixes);
        const candidates = WEAPON_AFFIX_POOL.filter(a => {
            if (existing.has(a.id)) return false;
            if (a.prereq && !existing.has(a.prereq)) return false;
            return true;
        });
        if (candidates.length === 0) return;
        const chosen = candidates[Math.floor(Math.random() * candidates.length)];
        hero.weaponRefineAffixes.push(chosen.id);
    }

    function updateWeaponRefineAffixes() {
        // æ¯ +3 ç²¾ç·´ï¼Œå¤šä¸€æ¢
        const targetSlots = Math.floor(hero.weaponRefineLevel / 3);
        if (targetSlots > hero.weaponRefineSlots) {
            for (let i = 0; i < targetSlots - hero.weaponRefineSlots; i++) {
                addRandomAffixToWeaponRefine();
            }
        } else if (targetSlots < hero.weaponRefineSlots) {
            for (let i = 0; i < hero.weaponRefineSlots - targetSlots; i++) {
                if (hero.weaponRefineAffixes.length > 0) hero.weaponRefineAffixes.pop();
            }
        }
        hero.weaponRefineSlots = targetSlots;
    }

    function addRandomAffix(equip, pool) {
        if (!equip.affixes) equip.affixes = [];
        const existing = new Set(equip.affixes);
        const candidates = pool.filter(a => {
            if (existing.has(a.id)) return false;
            if (a.prereq && !existing.has(a.prereq)) return false;
            return true;
        });
        if (candidates.length === 0) return;
        const chosen = candidates[Math.floor(Math.random() * candidates.length)];
        equip.affixes.push(chosen.id);
    }

    function updateShieldRefineAffixes(equip) {
        if (!equip) return;
        if (equip.refine == null) equip.refine = 0;
        if (equip.refineSlots == null) equip.refineSlots = 0;
        // æ¯ +3 ç²¾ç·´ï¼Œå¤šä¸€æ¢
        const targetSlots = Math.floor(equip.refine / 3);
        if (targetSlots > equip.refineSlots) {
            for (let i = 0; i < targetSlots - equip.refineSlots; i++) {
                addRandomAffix(equip, SHIELD_AFFIX_POOL);
            }
        } else if (targetSlots < equip.refineSlots) {
            for (let i = 0; i < equip.refineSlots - targetSlots; i++) {
                if (equip.affixes && equip.affixes.length > 0) equip.affixes.pop();
            }
        }
        equip.refineSlots = targetSlots;
    }

    const RARITY_COLORS = {
        'Normal': 'Rarity-Normal',
        'Magic': 'Rarity-Magic',
        'Rare': 'Rarity-Rare',
        'Epic': 'Rarity-Epic',
        'Legendary': 'Rarity-Legendary',
        'Mythic': 'Rarity-Mythic'
    };

    // å°æ€ª / ç‹
    const ENEMIES = {
        SMALL: [
            { name: "å“¥å¸ƒæ—", hp: 32, atk: 9, def: 8,  mDef: 12,  dodge: 35, lootChance: 0.80, exp: 8,  bias: { 'âš”ï¸': 0.3, 'ğŸŒ ': 0.4, 'ğŸ›¡ï¸': 0.3 } },
            { name: "éª·é«å…µ", hp: 45, atk: 8, def: 16, mDef: 6,  dodge: 5,  lootChance: 0.75, exp: 10, bias: { 'âš”ï¸': 0.3, 'ğŸŒ ': 0.3, 'ğŸ›¡ï¸': 0.4 } },
            { name: "é‡ç‹¼",  hp: 42, atk: 9, def: 6,  mDef: 24, dodge: 20, lootChance: 0.80, exp: 11, bias: { 'âš”ï¸': 0.6, 'ğŸŒ ': 0.2, 'ğŸ›¡ï¸': 0.2 } },
            { name: "çŸ³é ­äºº", hp: 60, atk: 8,  def: 30, mDef: 4,  dodge: 5,  lootChance: 0.75, exp: 14, bias: { 'âš”ï¸': 0.6, 'ğŸŒ ': 0.1, 'ğŸ›¡ï¸': 0.3 } },
            { name: "è™è ", hp: 22, atk: 10, def: 4,  mDef: 8, dodge: 60, lootChance: 0.85, exp: 7,  bias: { 'âš”ï¸': 0.2, 'ğŸŒ ': 0.5, 'ğŸ›¡ï¸': 0.3 } }
        ],
        BOSS: [
            { level: 1, name: "ä¸æ­»å·«å¦–", hp: 200, atk: 20, def: 10, mDef: 22, dodge: 10, lootChance: 1.0, exp: 70,  bias: { 'âš”ï¸': 0.2, 'ğŸŒ ': 0.5, 'ğŸ›¡ï¸': 0.3 } },
            { level: 2, name: "ç«ç„°å·¨é¾", hp: 380, atk: 28, def: 24, mDef: 12, dodge: 12, lootChance: 1.0, exp: 160, bias: { 'âš”ï¸': 0.5, 'ğŸŒ ': 0.2, 'ğŸ›¡ï¸': 0.3 } },
            { level: 3, name: "é å¤é­”ç¥", hp: 650, atk: 45, def: 26, mDef: 26, dodge: 15, lootChance: 1.0, exp: 380, bias: { 'âš”ï¸': 0.3, 'ğŸŒ ': 0.3, 'ğŸ›¡ï¸': 0.4 } }
        ]
    };

    const ENEMY_ART = {
        "å“¥å¸ƒæ—": [
            "",
            "/ï¼¼__/ï¼¼",
            "( o.o >",
            "( ^ )",
            "ï¼¼--/"
        ],
        "éª·é«å…µ": [
            "",
            " .-.",
            "( o )",
            " ï¼¼ï¼¼_/",
            " /ï¼¼ï¼¼"
        ],
        "é‡ç‹¼": [
            "",
            "/ï¼¼/ï¼¼",
            "( o.o )",
            "( ^ )",
            "\\-_/"
        ],
        "çŸ³é ­äºº": [
            "",
            "| O O |",
            "| \\_/ |",
            "|_____|",
            "| | |"
        ],
        "è™è ": [
            "",
            "ï¼¿      ï¼¿ ",
            "ï¼‰ï¼¼^ ^/ (",
            " )ï¼¿ã€‚ã€‚)(",
            "  |_ï¸¸_|",
            " _/Â¯Â¯Â¯ï¼¼_"
        ],
        "ä¸æ­»å·«å¦–": [
            "",
            "    +--[âš°ï¸]--+       ",
            "   | ( ğŸ’€ ğŸ’€ ) |    ",
            "   |  /|v|\\  |    ",
            "   /  `-----'  \\   ",
            "  `-------------'   "
        ],
        "ç«ç„°å·¨é¾": [
            "",
            "    <~ğŸ”¥~>  <~ğŸ”¥~>  ",
            "   /  ( ğŸ‰ ğŸ‰ )  \\ ",
            "  |    |  v  |    | ",
            "   \\  /\\_/\\_/\\  /   ",
            "    `----------'    "
        ],
        "é å¤é­”ç¥": [
            "",
            "    /\\/\\/\\/\\/\\   ",
            "   ( ğŸ‘ï¸ [X] ğŸ‘ï¸ )  ",
            "  |  /  |w|  \\  |  ",
            "   \\ |  |V|  | /    ",
            "    `-----------'   "
        ]
    };

    const ENEMY_INTRO_LINES = {
        "å“¥å¸ƒæ—": "å“¥å¸ƒæ—ï¼šã€å°é¢æœ‰å€‹å«Jackçš„å«æˆ‘ä¾†é€™ï¼Œèªªé€™æœ‰å¥½åº·?ã€",
        "éª·é«å…µ": "éª·é«å…µï¼šã€å”‰~æˆ¿è²¸é‚„æ²’ç¹³å®Œå°±æ­»äº†ï¼Œåªå¥½å›ä¾†åŠ ç­ã€‚ã€",
        "é‡ç‹¼":   "é‡ç‹¼ï¼šã€æˆ‘å‰›å‰›UBERé»çš„åˆé¤å°±æ˜¯ä½ å—?ã€",
        "çŸ³é ­äºº": "çŸ³é ­äººï¼šã€æˆ‘çš„çš®å¾ˆç¡¬ï¼Œæˆ‘çš„è‚æ›´ç¡¬ã€‚ã€",
        "è™è ":   "è™è ï¼šã€ä»€éº¼å‹•ç‰©ä¸ç”¨ä¼‘æ¯ï¼Ÿã€..................ç­”ï¼šã€è™è ï¼Œå› ç‚ºä¸ä¼‘è™è ã€",
        "ä¸æ­»å·«å¦–": "ä¸æ­»å·«å¦–ï¼šã€ä½ å•æˆ‘æ°¸ç”Ÿçš„ç§˜è¨£ï¼Ÿæ¯å¤©ç¡æ»¿å…«å°æ™‚ï¼Œç„¶å¾Œå¤šé‹å‹•ï¼Œå°±é€™éº¼ç°¡å–®ã€‚ã€",
        "ç«ç„°å·¨é¾": "ç«ç„°å·¨é¾ï¼šã€æˆ‘æœƒå™´ç«æ˜¯å› ç‚ºæˆ‘æœ‰åš´é‡çš„èƒƒé£Ÿé“é€†æµï¼Œæ™šé¤åƒå¤ªè¾£äº†ã€‚ã€",
        "é å¤é­”ç¥": "é å¤é­”ç¥ï¼šã€æˆ‘å°±æ˜¯è³‡æœ¬ä¸»ç¾©çš„å…·è±¡åŒ–ï¼Œä½ æ¯å¤©éƒ½å¾—å¹«æˆ‘æ‰“å·¥ã€‚ã€"
    };

    const mainView = document.getElementById('main-view');
    const messageLog = document.getElementById('message-log');
    const heroAtkVal = document.getElementById('hero-atk-val');
    const heroDefVal = document.getElementById('hero-def-val');
    const heroMatkVal = document.getElementById('hero-matk-val');
    const heroDodgeVal = document.getElementById('hero-dodge-val');
    const heroTieWinRateVal = document.getElementById('hero-tie-win-rate-val');
    const heroCritVal = document.getElementById('hero-crit-val');

    const commandMenu = document.getElementById('command-menu');
    const decisionMenu = document.getElementById('decision-menu');
    const btnDecYes = document.getElementById('btn-decision-yes');
    const btnDecNo = document.getElementById('btn-decision-no');

    const btn1 = document.getElementById('btn-action-1');
    const btn2 = document.getElementById('btn-action-2');
    const btn3 = document.getElementById('btn-action-3');

    const eqWeapon = document.getElementById('eq-weapon');
    const eqShield = document.getElementById('eq-shield');
    const eqRing = document.getElementById('eq-ring');
    const eqDetailWeapon = document.getElementById('eq-detail-weapon');
    const eqDetailShield = document.getElementById('eq-detail-shield');
    const eqDetailRing = document.getElementById('eq-detail-ring');
    const eqWeaponAffix = document.getElementById('eq-weapon-affix');
    const eqShieldAffix = document.getElementById('eq-shield-affix');

    const heroHpSpan = document.getElementById('hero-hp');
    const heroMaxHpSpan = document.getElementById('hero-max-hp');
    const heroLevelSpan = document.getElementById('hero-level');
    const heroExpSpan = document.getElementById('hero-exp');
    const heroExpMaxSpan = document.getElementById('hero-exp-max');
    // æŠŠç¨±è™Ÿå¡é€² hero-titleåœ¨é€™è£¡åŠ  â†“
    const heroTitleSpan = document.getElementById('hero-title');
    const turnCountSpan = document.getElementById('turn-count');  // â† æ–°å¢
    const weaponRefineLevelSpan = document.getElementById('weapon-refine-level');
    const shieldRefineLevelSpan = document.getElementById('shield-refine-level');
    const weaponMaterialsSpan = document.getElementById('weapon-materials');
    const shieldMaterialsSpan = document.getElementById('shield-materials');

    function randInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function getEffectivePower(eq, slotType) {
        if (!eq) return 0;
        let base = eq.power || 0;
        if (slotType === 'SHIELD' && eq.refine && eq.refine > 0) {
            const per = 0.08;
            base = Math.floor(base * (1 + eq.refine * per));
        }
        return base;
    }

    function getMagicAttackValue() {
        let magic = hero.currentMagicAtk;
        const ring = hero.equipment.RING;
        if (ring && ring.ability) {
            if (ring.ability.id === 'MAGIC') {
                const rate = MAGIC_RING_MAGIC_RATE[ring.tier] || 0;
                magic = Math.floor(magic * (1 + rate));
            } else if (ring.ability.id === 'CRIT') {
                const rate = CRIT_RING_MAGIC_RATE[ring.tier] || 0;
                magic = Math.floor(magic * (1 + rate));
            }
        }
        if (magic < 0) magic = 0;
        return magic;
    }

    function getHeroBaseCritChance() {
        let base = 0.05;
        const affSet = getAllWeaponAffixSet();
        if (affSet.has('W_CRIT_UP')) base += 0.05;
        return base;
    }

    function getHeroCritChance() {
        let chance = getHeroBaseCritChance();
        const wAff = getAllWeaponAffixSet();
        const ring = hero.equipment.RING;

        if (wAff.has('W_BRAVE') && hero.hp > 0 && hero.hp <= hero.maxHp * 0.3) {
            chance += 0.10;
        }

        if (ring && ring.ability) {
            if (ring.ability.id === 'CRIT') {
                chance = 0.10 + ring.tier * 0.10;
            } else if (ring.ability.id === 'BERSERKER') {
                const extra = [0, 0.05, 0.06, 0.08, 0.10];
                chance += extra[ring.tier] || 0.05;
            }
        }
        if (chance < 0) chance = 0;
        if (chance > 0.9) chance = 0.9;
        return chance;
    }

    function getHeroCritRate() {
        return getHeroCritChance() * 100;
    }

    function attemptWeaponRefine() {
        const w = hero.equipment.WEAPON;
        if (!w || w.name === "å¾’æ‰‹") {
            log("â— ç›®å‰æ²’æœ‰å¯ç²¾ç·´çš„æ­¦å™¨ï¼ˆå¾’æ‰‹ä¸ç²¾ç·´ï¼‰ã€‚");
            return;
        }
        hero.weaponRefineLevel += 1;
        log(`ğŸ›  æ­¦å™¨ç²¾ç·´æˆåŠŸï¼å…¨æ­¦å™¨ç²¾ç·´ç­‰ç´šæå‡ç‚º +${hero.weaponRefineLevel}ï¼ˆæ›æ–°æ­¦å™¨ä¹Ÿæœƒæ²¿ç”¨ï¼‰ã€‚`);
        updateWeaponRefineAffixes();
    }

    function attemptShieldRefine() {
        const s = hero.equipment.SHIELD;
        if (!s || s.name === "ç„¡") {
            log("â— ç›®å‰æ²’æœ‰å¯ç²¾ç·´çš„ç›¾ç‰Œã€‚");
            return;
        }
        if (!s.refine) s.refine = 0;
        s.refine += 1;
        log(`ğŸ›¡ ç›¾ç‰Œç²¾ç·´æˆåŠŸï¼${s.name} ç²¾ç·´ +${s.refine}ã€‚`);
        updateShieldRefineAffixes(s);
    }

    function log(message) {
        const div = document.createElement('div');
        div.className = 'log-msg';
        div.innerHTML = `> ${message}`;
        messageLog.prepend(div);
        if (messageLog.children.length > 80) {
            messageLog.removeChild(messageLog.lastChild);
        }
    }

    function calculateHeroStats() {
        const weaponPower = getEffectivePower(hero.equipment.WEAPON, 'WEAPON');
        const shieldPower = getEffectivePower(hero.equipment.SHIELD, 'SHIELD');

        hero.currentAttack = hero.baseAttack + weaponPower;
        hero.currentDefense = hero.baseDefense + shieldPower;
        hero.healRingDefBonus = 0;

        const ring = hero.equipment.RING;

        if (ring.ability && ring.ability.id === 'HEAL') {
            const tier = ring.tier;
            const ratio = Math.min(0.12, 0.03 * tier);
            const extraDef = Math.floor(hero.currentDefense * ratio);
            hero.currentDefense += extraDef;
            hero.healRingDefBonus = extraDef;
        }

        let ringDodgeBonus = 0;
        if (ring.ability && ring.ability.id === 'DODGE') {
            ringDodgeBonus = ring.ability.effect(hero) * 100;
        }

        hero.currentTieWinRate = hero.baseTieWinRate;
        if (ring.ability && ring.ability.id === 'BALANCE') {
            hero.currentTieWinRate += ring.ability.effect(ring.tier);
        }

        const shield = hero.equipment.SHIELD;
        if (shield && shield.affixes) {
            if (shield.affixes.includes('S_DEF_UP')) {
                hero.currentDefense = Math.floor(hero.currentDefense * 1.10);
            }
            if (shield.affixes.includes('S_TIE_UP')) {
                hero.currentTieWinRate += 5;
            }
            if (shield.affixes.includes('S_DODGE_UP')) {
                ringDodgeBonus += 5;
            }
        }

        hero.currentTieWinRate = Math.min(100, hero.currentTieWinRate);

        hero.berserkerBonus = 0;
        hero.berserkerPenalty = 0;

        if (ring.ability && ring.ability.id === 'BERSERKER') {
            const tier = ring.tier;
            const ratio = ring.ability.effect(tier);
            const hpToAtk = Math.floor(hero.maxHp * ratio);
            const defReduction = Math.floor(hero.currentDefense * 0.15);
            hero.currentAttack += hpToAtk;
            hero.currentDefense -= defReduction;
            hero.berserkerBonus = hpToAtk;
            hero.berserkerPenalty = defReduction;
        }

        if (hero.defDownTurns > 0 && hero.defDownRate > 0) {
            const reduce = Math.floor(hero.currentDefense * hero.defDownRate);
            hero.currentDefense = Math.max(0, hero.currentDefense - reduce);
        }

        hero.currentDefense = Math.max(0, hero.currentDefense);

        // é–ƒé¿è¨ˆç®—ï¼šå…ˆç®— rawï¼Œå†æ‹†æˆé¡¯ç¤º + æº¢å‡ºè¿½æ“Š
        const wAff = getAllWeaponAffixSet();

        // æ­¦å™¨è©æ¢ï¼šçŸ¥è­˜å°±æ˜¯åŠ›é‡ï¼ˆW_ATK_UPï¼‰â†’ ç‰©ç†æ”»æ“Š +12%
        if (wAff.has('W_ATK_UP')) {
            hero.currentAttack = Math.floor(hero.currentAttack * 1.12);
        }

        // æ­¦å™¨è©æ¢ï¼šå†åŠ æŠŠå‹ï¼ˆW_BALANCEï¼‰â†’ å¹³æ‰‹å‹ç‡ +7%
        if (wAff.has('W_BALANCE')) {
            hero.currentTieWinRate += 7;
        }

        // å†æ¬¡å£“ä¸Šé™ï¼Œé¿å…è¶…é 100%
        hero.currentTieWinRate = Math.min(100, hero.currentTieWinRate);

        // é–ƒé¿è¨ˆç®—ï¼šå…ˆç®— rawï¼Œå†æ‹†æˆé¡¯ç¤º + æº¢å‡ºè¿½æ“Š
        let rawDodge = hero.baseDodge + ringDodgeBonus;
        if (wAff.has('W_DODGE_UP')) rawDodge += 3;

        hero.dodgeOverflow = 0;
        if (ring.ability && ring.ability.id === 'DODGE' && rawDodge > 75) {
            hero.dodgeOverflow = rawDodge - 75;
        }
        hero.currentDodge = Math.min(75, rawDodge);

        const rarity = hero.equipment.WEAPON.rarity || 'Normal';
        const per = MAGIC_REFINE_BONUS[rarity] || 0;
        hero.currentMagicAtk = hero.baseMagicAtk + hero.weaponRefineLevel * per;
        if (wAff.has('W_MAGIC_UP')) {
            hero.currentMagicAtk = Math.floor(hero.currentMagicAtk * 1.10);
        }
        if (wAff.has('W_BRAVE') && hero.hp > 0 && hero.hp <= hero.maxHp * 0.3) {
            hero.currentAttack = Math.floor(hero.currentAttack * 1.15);
        }
        if (hero.currentMagicAtk < 0) hero.currentMagicAtk = 0;
    }

    function getAllWeaponAffixNames() {
        const ids = new Set();
        (hero.equipment.WEAPON.affixes || []).forEach(id => ids.add(id));
        (hero.weaponRefineAffixes || []).forEach(id => ids.add(id));
        if (ids.size === 0) return 'ç„¡';
        return Array.from(ids).map(id => {
            const a = findAffix(WEAPON_AFFIX_POOL, id);
            return a ? a.name : id;
        }).join('ã€');
    }

    function getShieldAffixNames() {
        const s = hero.equipment.SHIELD;
        if (!s || !s.affixes || s.affixes.length === 0) return 'ç„¡';
        return s.affixes.map(id => {
            const a = findAffix(SHIELD_AFFIX_POOL, id);
            return a ? a.name : id;
        }).join('ã€');
    }

    function updateStatus() {
        calculateHeroStats();

        heroHpSpan.textContent = Math.max(0, hero.hp);
        heroMaxHpSpan.textContent = hero.maxHp;
        heroLevelSpan.textContent = hero.level;
        heroExpSpan.textContent = hero.exp;
        heroExpMaxSpan.textContent = hero.expToNextLevel;

        // æ›´æ–°ç¨±è™Ÿé¡¯ç¤ºï¼šã€Œå‹‡è€… ç§°è™Ÿ: Lv...ã€
        const title = hero.title || '';   // çœ‹ä½ ç¨±è™Ÿæ˜¯å­˜ hero.title é‚„æ˜¯ heroTitle
        if (heroTitleSpan) {
            heroTitleSpan.textContent = title ? ` ${title}` : '';
        }
        // â˜… æ–°å¢ï¼šæ›´æ–°å›åˆæ•¸
        if (turnCountSpan) {
            turnCountSpan.textContent = turnCount;
        }

        heroAtkVal.textContent = hero.currentAttack;
        heroDefVal.textContent = hero.currentDefense;
        heroMatkVal.textContent = getMagicAttackValue();
        heroDodgeVal.textContent = hero.currentDodge.toFixed(1);
        heroTieWinRateVal.textContent = hero.currentTieWinRate.toFixed(1);
        heroCritVal.textContent = getHeroCritRate().toFixed(1);

        const wEq = hero.equipment.WEAPON;
        const sEq = hero.equipment.SHIELD;
        const rEq = hero.equipment.RING;

        const effW = getEffectivePower(wEq, 'WEAPON');
        const effS = getEffectivePower(sEq, 'SHIELD');

        eqWeapon.innerHTML = `<span class="${RARITY_COLORS[wEq.rarity]}">${wEq.name}</span>`;
        eqShield.innerHTML = `<span class="${RARITY_COLORS[sEq.rarity]}">${sEq.name}${sEq.refine ? ' +' + sEq.refine : ''}</span>`;
        eqRing.innerHTML = `<span class="${RARITY_COLORS[rEq.rarity]}">${rEq.name}</span>`;

        eqDetailWeapon.innerHTML =
            `<span class="${RARITY_COLORS[wEq.rarity]}">æ”»æ“ŠåŠ› +${effW}ï¼Œé­”æ”» +${getMagicAttackValue()}</span>`;
        eqDetailShield.innerHTML =
            `<span class="${RARITY_COLORS[sEq.rarity]}">é˜²ç¦¦åŠ› +${effS}${sEq.refine ? ` (ç²¾ç·´+${sEq.refine})` : ''}</span>`;

        let ringDetailText = `ç‰¹æ•ˆï¼š${rEq.ability.desc} (Lv.${rEq.tier})`;
        const ringId = rEq.ability.id;
        const tier = rEq.tier;

        if (ringId === 'BERSERKER') {
            ringDetailText += `<span style="color:red;"> (ATK+${hero.berserkerBonus}, DEF-${hero.berserkerPenalty}ï¼Œç‰©æ”»å¤šæ®µ&å°å¹…çˆ†æ“ŠåŠ æˆ)</span>`;
        } else if (ringId === 'HEAL' && hero.healRingDefBonus > 0) {
            const extraRatio = Math.min(0.12, 0.03 * tier) * 100;
            ringDetailText += `<span style="color:#2196F3;"> (é˜²ç¦¦+${hero.healRingDefBonus}ï¼Œé˜²ç¦¦åŠ æˆç´„ +${extraRatio.toFixed(0)}%)</span>`;
        } else if (ringId === 'MAGIC') {
            const rate = (MAGIC_RING_MAGIC_RATE[tier] || 0) * 100;
            ringDetailText += `<span style="color:#9c27b0;"> (é­”æ³•å‚·å®³ +${rate.toFixed(0)}%)</span>`;
        } else if (ringId === 'CRIT') {
            const critRate = getHeroCritRate();
            const mRate = (CRIT_RING_MAGIC_RATE[tier] || 0) * 100;
            ringDetailText += `<span style="color:#ff9800;"> (ç æ“Šçˆ†æ“Šç‡ç´„ ${critRate.toFixed(0)}%ï¼Œé­”æ³•å‚·å®³ +${mRate.toFixed(0)}%)</span>`;
        } else if (ringId === 'DODGE') {
            ringDetailText += `<span style="color:#4caf50;"> (ç›®å‰é¡¯ç¤ºé–ƒé¿ç´„ ${hero.currentDodge.toFixed(1)}%ï¼Œè¿½æ“Šæ©Ÿç‡ç´„ ${hero.dodgeOverflow.toFixed(1)}%)</span>`;
        } else if (ringId === 'BALANCE') {
            ringDetailText += `<span style="color:#03a9f4;"> (å¹³æ‰‹å‹ç‡ç›®å‰ç´„ ${hero.currentTieWinRate.toFixed(1)}%)</span>`;
        } else if (ringId === 'NONE') {
            ringDetailText = `ç‰¹æ•ˆï¼šç„¡ (Lv.0)`;
        }
        eqDetailRing.innerHTML = `<span class="${RARITY_COLORS[rEq.rarity]}">${ringDetailText}</span>`;

        eqWeaponAffix.innerHTML = getAllWeaponAffixNames();
        eqShieldAffix.innerHTML = getShieldAffixNames();

        weaponRefineLevelSpan.textContent = hero.weaponRefineLevel;
        shieldRefineLevelSpan.textContent = getShieldRefineLevel();
        weaponMaterialsSpan.textContent = weaponMaterials;
        shieldMaterialsSpan.textContent = shieldMaterials;

        document.getElementById("turn-count").textContent = `å›åˆï¼š${turnCount}`;
    }

     // â˜… æ›´æ–°å›åˆæ•¸å°å·¥å…·
    function spendTurn(n = 1) {
        turnCount += n;
        updateStatus();
    }

    function setCommands(c1, c2, c3, actionHandler, state) {
        btn1.textContent = c1.text;
        btn2.textContent = c2.text;
        btn3.textContent = c3.text;

        btn1.onclick = () => actionHandler(c1.value);
        btn2.onclick = () => actionHandler(c2.value);
        btn3.onclick = () => actionHandler(c3.value);

        btn1.classList.remove('defend-btn');
        btn2.classList.remove('defend-btn');
        btn3.classList.remove('defend-btn');

        commandMenu.style.display = 'flex';
        decisionMenu.style.display = 'none';

        if (state === 'BATTLE') {
            if (c3.value === 'ğŸš«') btn3.classList.add('defend-btn');
            commandMenu.querySelectorAll('.command-btn').forEach(btn => btn.disabled = false);
        } else if (state === 'MAP') {
            commandMenu.querySelectorAll('.command-btn').forEach(btn => btn.disabled = false);
            checkHealCooldown();
        }
    }

    function flashBattleView(type) {
        let className = 'hero-hit-flash';
        if (type === 'crit') className = 'crit-flash';
        else if (type === 'heal') className = 'heal-flash';
        else if (type === 'monster-hit') className = 'monster-hit-flash';

        mainView.classList.add(className);
        setTimeout(() => mainView.classList.remove(className), 300);
    }

    function battleTransition(callback) {
        mainView.innerHTML = `<h1>é€²å…¥æˆ°é¬¥...</h1>`;
        disableCommands(true);
        let count = 0;
        const interval = setInterval(() => {
            if (count % 2 === 0) {
                mainView.classList.remove('transition-flash-off');
                mainView.classList.add('transition-flash-on');
            } else {
                mainView.classList.remove('transition-flash-on');
                mainView.classList.add('transition-flash-off');
            }
            count++;
            if (count > 5) {
                clearInterval(interval);
                mainView.classList.remove('transition-flash-on', 'transition-flash-off');
                mainView.style.backgroundColor = '#1a2a3a';
                callback();
            }
        }, 200);
    }

    function showLootAnimation(loot) {
        return new Promise(resolve => {
            const rarityClass = `loot-${loot.rarity}`;
            mainView.classList.add(rarityClass);
            mainView.innerHTML = `
                <p style="text-shadow: 0 0 10px currentColor;">âœ¨ ç²å¾—æ–°å¯¶ç‰©! âœ¨</p>
                <p>${loot.name}</p>
            `;
            setTimeout(() => {
                mainView.classList.remove(rarityClass);
                mainView.style.backgroundColor = '#1a2a3a';
                resolve();
            }, 1500);
        });
    }

    function enterMap() {
        if (gameState === 'CREDITS') {
            mainView.style.whiteSpace = 'pre-wrap';
        }
        gameState = 'MAP';
        updateStatus();
        mainView.style.backgroundColor = '#1a2a3a';
        mainView.innerHTML = `<p>ğŸ—ºï¸ å‹‡è€… ${hero.name} (Lv.${hero.level})ï¼Œä»Šå¤©è¦å»å“ªè£¡äº‚æ™ƒï¼Ÿ</p>`;

        const maxBossLevel = ENEMIES.BOSS.length;
        let c2Text;
        if (bossLevel > maxBossLevel) {
            c2Text = "ğŸ‰ å·²æ“Šæ•—æ‰€æœ‰ Boss";
            btn2.disabled = true;
        } else {
            c2Text = `æŒ‘æˆ° Boss ${bossLevel} å¯¶è—`;
            btn2.disabled = false;
        }

        setCommands(
            { text: "å‡ºç™¼å†’éšª", value: 'Small' },
            { text: c2Text, value: 'Boss' },
            { text: "ä¼‘æ¯ (æ¢å¾© HP)", value: 'Heal' },
            handleMapAction,
            'MAP'
        );
    }

    function checkHealCooldown() {
        const healBtn = btn3;
        const now = Date.now();
        const remaining = (lastHealTime + healCooldown) - now;
        if (remaining > 0) {
            setHealCooldown(remaining);
        } else {
            healBtn.textContent = 'ä¼‘æ¯ (æ¢å¾© HP)';
            healBtn.disabled = false;
            clearInterval(healCooldownTimer);
        }
    }

    function setHealCooldown(initialRemaining) {
        const healBtn = btn3;
        if (gameState === 'MAP') healBtn.disabled = true;
        clearInterval(healCooldownTimer);

        let remainingSeconds = Math.ceil(initialRemaining / 1000);
        healCooldownTimer = setInterval(() => {
            if (remainingSeconds <= 0) {
                clearInterval(healCooldownTimer);
                if (gameState === 'MAP') {
                    healBtn.textContent = 'ä¼‘æ¯ (æ¢å¾© HP)';
                    healBtn.disabled = false;
                }
            } else {
                if (gameState === 'MAP') {
                    healBtn.textContent = `ä¼‘æ¯ (${remainingSeconds}s)`;
                }
                remainingSeconds--;
            }
        }, 1000);

        if (remainingSeconds > 0 && gameState === 'MAP') {
            healBtn.textContent = `ä¼‘æ¯ (${remainingSeconds}s)`;
        }
    }

    // ===== å†’éšªäº‹ä»¶å€ =====

    function startSmallBattle() {
        const index = Math.floor(Math.random() * ENEMIES.SMALL.length);
        const enemyData = ENEMIES.SMALL[index];

        const levelFactor = 1 + (hero.level - 1) * 0.52; // â† å°æ€ªæ•´é«”æˆé•·å€ç‡
        const scaledHp   = Math.floor(enemyData.hp   * levelFactor);
        const scaledAtk  = Math.floor(enemyData.atk  * levelFactor);
        const scaledDef  = Math.floor((enemyData.def  || 0) * (1 + (hero.level - 1) * 0.22)); // â† å°æ€ªdefæˆé•·
        const scaledMDef = Math.floor((enemyData.mDef || enemyData.def || 0) * (1 + (hero.level - 1) * 0.22));// â† å°æ€ªMdefæˆé•·

        currentEnemy = {
            ...enemyData,
            originalHp: scaledHp,
            hp: scaledHp,
            atk: scaledAtk,
            def: scaledDef,
            mDef: scaledMDef
        };
        battleTransition(enterBattle);
    }

    function startEliteBattle() {
        const baseIndex = Math.min(Math.max(bossLevel - 1, 0), ENEMIES.BOSS.length - 1);
        const bossData = ENEMIES.BOSS[baseIndex];

        const scaledHp   = Math.floor(bossData.hp   * 0.6);
        const scaledAtk  = Math.floor(bossData.atk  * 0.7);
        const scaledDef  = Math.floor((bossData.def  || 0) * 0.7);
        const scaledMDef = Math.floor((bossData.mDef || bossData.def || 0) * 0.7);

        const eliteNames = [
            "è¿·è·¯çš„ç‰›é ­äººèè‹±",
            "åº¦å‡ä¸­çš„è¿·ä½ ä¹é ­è›‡",
            "è¢«ç¸®å°çš„é å¤å°é­”ç¥"
        ];
        const eName = eliteNames[baseIndex] || "ä¸å¤ªæƒ³ä¸Šç­çš„èè‹±æ€ª";

        currentEnemy = {
            level: bossData.level,
            name: eName,
            originalHp: scaledHp,
            hp: scaledHp,
            atk: scaledAtk,
            def: scaledDef,
            mDef: scaledMDef,
            dodge: bossData.dodge,
            lootChance: 0.9,
            exp: Math.floor(bossData.exp * 0.5),
            bias: bossData.bias
        };
        log(`ğŸ˜ˆ ä½ ä¸å°å¿ƒé‘½é€²å¥‡æ€ªçš„å°å··ï¼Œæ’è¦‹ä¸€éš»ã€èè‹±æ€ªã€‘ï¼š${eName}ï¼`);
        battleTransition(enterBattle);
    }

    function adventureTreasure() {
        const matType = Math.random() < 0.5 ? 'WEAPON' : 'SHIELD';
        const gain = randInt(2, 4);
        if (matType === 'WEAPON') {
            weaponMaterials += gain;
            log(`ğŸ’° ä½ è¸¢åˆ°ä¸€å€‹å¯ç–‘æœ¨ç®±ï¼Œè£¡é¢å…¨æ˜¯éµå±‘ï¼æ­¦å™¨ç´ æ +${gain} (ç›®å‰ ${weaponMaterials}/${WEAPON_MATERIAL_PER_REFINE})`);
            while (weaponMaterials >= WEAPON_MATERIAL_PER_REFINE) {
                weaponMaterials -= WEAPON_MATERIAL_PER_REFINE;
                attemptWeaponRefine();
            }
        } else {
            shieldMaterials += gain;
            log(`ğŸ“¦ ä½ æ’¿åˆ°ä¸€é¢å£æ‰çš„ç›¾ç‰Œå †ï¼Œæ‹†ä¸€æ‹†å¾—åˆ°ç›¾ç‰Œç´ æ +${gain} (ç›®å‰ ${shieldMaterials}/${SHIELD_MATERIAL_PER_REFINE})`);
            while (shieldMaterials >= SHIELD_MATERIAL_PER_REFINE) {
                shieldMaterials -= SHIELD_MATERIAL_PER_REFINE;
                attemptShieldRefine();
            }
        }
        const bonusExp = randInt(5, 15);
        gainExp(bonusExp);
        log(`ğŸ ä½ é †æ‰‹ç¿»æ‰¾ï¼Œé‚„ç²å¾—äº†ä¸€é»é›œä¸ƒé›œå…«çš„ç¶“é©—å€¼ +${bonusExp}ã€‚`);
        updateStatus();
        setTimeout(enterMap, 800);
    }

    function adventureSpring() {
        hero.hp = hero.maxHp;
        hero.burnTurns = 0;
        hero.burnDamage = 0;
        hero.defDownTurns = 0;
        hero.defDownRate = 0;
        hero.magicGuardTurns = 0;
        log("ğŸ’§ ä½ ç™¼ç¾ä¸€å€‹ç™¼å…‰çš„æ²»ç™‚æ³‰æ°´ï¼Œæ³¡å®Œæ•´å€‹äººåƒå‰›ä¸Š SPAï¼ŒHP å…¨æ»¿ï¼Œå„ç¨® debuff è¢«æ´—æ‰ã€‚");
        flashBattleView('heal');
        updateStatus();
        setTimeout(enterMap, 800);
    }

    function adventureNiceGuy() {
        const roll = Math.random();
        if (roll < 0.4) {
            hero.buffDamageUpTurns = 5;
            hero.buffDamageUpRate = 0.3;
            log("ğŸ§™ ä¸€ä½è·¯éçš„å¥¶æ²¹æ³•å¸«æ‹æ‹ä½ è‚©è†€ï¼šã€ç­‰ä¸€ä¸‹ 5 å›åˆå…§ä½ æœƒè®Šè¶…ç—›ã€‚ã€(å‚·å®³æå‡ buff)");
        } else if (roll < 0.8) {
            hero.regenTurns = 5;
            hero.regenAmount = Math.max(2, Math.floor(hero.maxHp * 0.05));
            log(`ğŸ² ä¸€å€‹å¥½å¿ƒå¤§å¬¸å¡çµ¦ä½ æš–å‘¼å‘¼é›æ¹¯ï¼Œæœªä¾† 5 å›åˆé–‹å§‹æ™‚éƒ½æœƒå›å¾©ç´„ ${hero.regenAmount} HPã€‚`);
        } else {
            const matGain = randInt(1, 3);
            weaponMaterials += matGain;
            log(`ğŸš¶ ä½ é‡åˆ°ä¸€å€‹çœ‹èµ·ä¾†å¾ˆæœ‰éŒ¢çš„å†’éšªè€…ï¼Œä»–èªªä¸æƒ³æ‰“æ€ªäº†ï¼ŒæŠŠèº«ä¸Š ${matGain} ä»½æ­¦å™¨ç´ æå¡çµ¦ä½ å°±èµ°äº†ã€‚`);
            while (weaponMaterials >= WEAPON_MATERIAL_PER_REFINE) {
                weaponMaterials -= WEAPON_MATERIAL_PER_REFINE;
                attemptWeaponRefine();
            }
        }
        updateStatus();
        setTimeout(enterMap, 800);
    }

    function adventureLoveScam() {
        const r = Math.random();
        if (r < 0.5) {
            const lost = Math.max(1, Math.floor(hero.maxHp * 0.2));
            hero.hp = Math.max(1, hero.hp - lost);
            log(`ğŸ’” ä½ é‡åˆ°ä¸€ä½è‡ªç¨±ã€Œæœƒæ°¸é æ„›ä½ çš„ã€çš„æ„›æƒ…é¨™å­ï¼Œè¢«é¨™èµ°äº† ${lost} é» HPï¼ˆæ°£åˆ°å…§å‚·ï¼‰ã€‚`);
        } else {
            const maxLoss = Math.floor(hero.expToNextLevel * 0.3);
            const realLoss = Math.min(hero.exp, maxLoss);
            hero.exp -= realLoss;
            log(`ğŸ“‰ å°æ–¹èªªã€Œå¹«ä½ ä½œè‚¡ç¥¨æŠ•è³‡ã€ï¼ŒçµæœæŠ•è³‡å¤±åˆ©ï¼Œä½ å°‘äº† ${realLoss} é»ç¶“é©—å€¼ï¼Œä½†é‚„å¥½æ²’æœ‰æ‰ç´šã€‚`);
        }
        updateStatus();
        setTimeout(enterMap, 800);
    }

    function handleMapAction(action) {
        if (gameState !== 'MAP') return;

        totalTurnCount++;   // åœ°åœ–ä¸Šçš„æ¯å€‹å‹•ä½œéƒ½ç®— 1 å›åˆ
        
        if (action === 'Small') {
            const roll = Math.random();
            if (roll < 0.58) {               // æ™®é€šå°æ€ª
                startSmallBattle();
            } else if (roll < 0.73) {        // èè‹±æ€ª
                startEliteBattle();
            } else if (roll < 0.85) {        // å¯¶ç®±
                adventureTreasure();
            } else if (roll < 0.92) {        // æ²»ç™‚æ³‰æ°´
                adventureSpring();
            } else if (roll < 0.97) {        // å¥½å¿ƒäºº
                adventureNiceGuy();
            } else {                         // æ„›æƒ…é¨™å­
                adventureLoveScam();
            }
        } else if (action === 'Boss') {
            if (bossLevel > ENEMIES.BOSS.length) return;
            const enemyData = ENEMIES.BOSS[bossLevel - 1];

            const effectiveLevel = Math.max(hero.level, enemyData.level * 7); //é€™å€‹æ±ºå®šã€Œå³ä½¿ä½ ç­‰ç´šå¾ˆä½ï¼ŒBoss è‡³å°‘æœƒè¢«ç•¶ä½œå¹¾ç­‰åœ¨ç®—ã€
            const levelFactor = 1 + (effectiveLevel - 1) * 0.25;  // â† Boss æˆé•·å€ç‡ï¼ˆBoss HP / ATK æˆé•·é€Ÿåº¦ï¼‰

            const scaledHp   = Math.floor(enemyData.hp   * levelFactor);
            const scaledAtk  = Math.floor(enemyData.atk  * levelFactor);
            const scaledDef  = Math.floor((enemyData.def  || 0) * (1 + (effectiveLevel - 1) * 0.14)); //ï¼ˆBoss DEF æˆé•·é€Ÿåº¦ï¼‰
            const scaledMDef = Math.floor((enemyData.mDef || enemyData.def || 0) * (1 + (effectiveLevel - 1) * 0.14)); //ï¼ˆBoss MDEF æˆé•·é€Ÿåº¦ï¼‰

            currentEnemy = {
                ...enemyData,
                originalHp: scaledHp,
                hp: scaledHp,
                atk: scaledAtk,
                def: scaledDef,
                mDef: scaledMDef
            };
            battleTransition(enterBattle);
        } else if (action === 'Heal') {
            const now = Date.now();
            if (now - lastHealTime < healCooldown) {
                const remainingSec = Math.ceil((healCooldown - (now - lastHealTime)) / 1000);
                log(`â±ï¸ ä¼‘æ¯å†·å»ä¸­! å°šé¤˜ ${remainingSec} ç§’ã€‚`);
                return;
            }
            const baseHeal = 5 + Math.floor(Math.random() * 5);
            const magicBonus = Math.floor(getMagicAttackValue() / 10);
            const healAmount = baseHeal + magicBonus;
            hero.hp = Math.min(hero.maxHp, hero.hp + healAmount);
            log(`ğŸ™ ä½ æ‰¾äº†å¡Šå®‰å…¨çš„çŸ³é ­åä¸‹ï¼Œæ¢å¾©äº† ${healAmount} é» HPã€‚(é­”æ”»åŠ æˆ +${magicBonus})`);
            flashBattleView('heal');
            updateStatus();

            lastHealTime = now;
            setHealCooldown(healCooldown);
        }
    }

    function enterBattle() {
        gameState = 'BATTLE';

        // æ€ªç‰©é–‹å ´åªè¬›ä¸€æ¬¡å¹¹è©±
        if (ENEMY_INTRO_LINES[currentEnemy.name]) {
            log(`ğŸ’¬ ${ENEMY_INTRO_LINES[currentEnemy.name]}`);
        }

        log(`é­é‡äº† ${currentEnemy.name}! è«‹é¸æ“‡ä½ çš„æ‹›å¼!`);

        // ç›¾ç‰Œ S_REGENï¼šé€²æˆ°é¬¥æ™‚çµ¦ä¸€é»æš«æ™‚å›è¡€
        const s = hero.equipment.SHIELD;
        if (s && s.affixes && s.affixes.includes('S_REGEN')) {
            hero.regenTurns = Math.max(hero.regenTurns, 3);
            hero.regenAmount = Math.max(hero.regenAmount, Math.max(2, Math.floor(hero.maxHp * 0.03)));
            log(`ğŸ›¡ï¸ã€åƒå€‹éºµåŒ…å…ˆã€‘ç”Ÿæ•ˆï¼šæœªä¾†å¹¾å›åˆé–‹å§‹æ™‚æœƒå°å¹…å›å¾© HPã€‚`);
        }

        updateBattleView();
        setCommands(
            { text: "âš”ï¸ ç æ“Š (ç‰©ç†)", value: 'âš”ï¸' },
            { text: "ğŸŒ  é­”æ³•æ”»æ“Š (å¿…ä¸­)", value: 'ğŸŒ ' },
            { text: "ğŸ›¡ï¸ ç›¾æ“Š (DEF ç„¡è¦–é˜²ç¦¦)", value: 'ğŸ›¡ï¸' },
            handleBattleAction,
            'BATTLE'
        );
        disableCommands(false);
    }

    function updateBattleView() {
        const art = ENEMY_ART[currentEnemy.name] || ENEMY_ART["éª·é«å…µ"];
        mainView.innerHTML = `
${currentEnemy.name}
HP: ${Math.max(0, currentEnemy.hp)}/${currentEnemy.originalHp}

${art.join('\n')}
        `;
        updateStatus();
    }

    // ç”Ÿå‘½æˆ’æŒ‡ï¼šå…±ç”¨å›è¡€å‡½æ•¸
    function healFromLifeRing(triggerSource) {
        const ring = hero.equipment.RING;
        if (!ring || !ring.ability || ring.ability.id !== 'HEAL' || ring.tier <= 0) return 0;
        if (hero.hp >= hero.maxHp) return 0;

        const baseRatio = 0.10 + ring.tier * 0.03;
        const raw = Math.floor(hero.currentDefense * baseRatio);
        const heal = Math.max(3, raw);
        const missing = hero.maxHp - hero.hp;
        const actual = Math.min(heal, missing);
        if (actual <= 0) return 0;

        hero.hp += actual;
        const srcText = triggerSource === 'BLOCK' ? 'æˆåŠŸæ ¼æ“‹' : 'ç›¾æ“Šå‘½ä¸­';
        log(`ğŸ’– ç”Ÿå‘½æˆ’æŒ‡ï¼š${srcText}ï¼Œä¾ DEF å›å¾© ${actual} HPï¼`);
        flashBattleView('heal');
        updateStatus();
        return actual;
    }

    // å¤šæ®µæ”»æ“Š & è€ç·´è€å±è‚¡é­”å‚· + è©³ç´° Log
    function applyHeroAttackEffects(baseDamage, isPhysical, attackKind, label) {
        let hits = 1;
        const ring = hero.equipment.RING;
        const tier = ring.tier;
        const critChance = getHeroCritChance();
        const wAff = getAllWeaponAffixSet();
        let totalDamage = 0;
        let hitDetails = [];
        const magicAtk = getMagicAttackValue();

        if (isPhysical && ring.ability && ring.ability.id === 'BERSERKER') {
            const multiChance = BERSERKER_MULTI_HIT_CHANCE[tier] || 0;
            const thirdChance = BERSERKER_THIRD_HIT_CHANCE[tier] || 0;
            if (Math.random() < multiChance) {
                hits++;
                if (Math.random() < thirdChance) hits++;
            }
        }

        if (isPhysical && wAff.has('W_EXTRA_HIT')) {
            if (Math.random() < 0.2) {
                hits++;
                log(`âš”ï¸ã€Œå·æ‘¸ä¸€æŠŠã€ç™¼å‹•ï¼Œå¤šæ‰“ä¸€æ“Šï¼`);
            }
        }

        if (isPhysical && wAff.has('W_RAGE')) {
            if (Math.random() < 0.05) {
                hits = Math.max(hits, 3);
                log(`ğŸ¤¬ã€Œç«å¤§äº‚ç ã€ç™¼å‹•ï¼Œæœ¬æ¬¡è‡³å°‘ 3 é€£æ“Šï¼`);
            }
        }

        let hasVeteran = isPhysical && attackKind === 'SWORD' && wAff.has('W_VETERAN');
        let hasChain = isPhysical && wAff.has('W_CHAIN');

        for (let i = 0; i < hits; i++) {
            let dmg = baseDamage;
            let thisHitCrit = false;
            let thisMagicBonus = 0;

            // æ‰“äº†åˆæ‰“ï¼šç¬¬äºŒæ“Šèµ·æ¯æ¬¡ +15%
            if (hasChain && i > 0) {
                const factor = 1 + 0.15 * i;
                dmg = Math.floor(dmg * factor);
            }

            // æš´æ“Šï¼ˆåªå°ç æ“Š / ä¸€èˆ¬ç‰©ç†ï¼‰
            if (isPhysical && attackKind === 'SWORD') {
                if (Math.random() < critChance) {
                    dmg = Math.floor(dmg * 2);
                    thisHitCrit = true;
                }
            }

            // è€ç·´è€å±è‚¡ï¼šç æ“Šé™„åŠ é­”æ”»æ¯”ä¾‹é­”å‚·
            if (hasVeteran && magicAtk > 0) {
                thisMagicBonus = Math.max(1, Math.floor(magicAtk * 0.30));
            }

            const singleTotal = dmg + thisMagicBonus;
            totalDamage += singleTotal;

            hitDetails.push({
                index: i + 1,
                dmg,
                isCrit: thisHitCrit,
                magicBonus: thisMagicBonus
            });
        }

        if (hitDetails.length > 1 || hitDetails.some(h => h.magicBonus > 0)) {
            const tag = label || 'æ”»æ“Š';
            log(`ğŸ“Š ${tag}è©³è§£ï¼š`);
            hitDetails.forEach(h => {
                let txt = `ç¬¬${h.index}æ“Šï¼š${h.dmg}`;
                if (isPhysical) txt += ` ç‰©ç†å‚·å®³`;
                if (h.isCrit) txt += `ï¼ˆæš´æ“Šï¼‰`;
                if (h.magicBonus > 0) txt += ` + ${h.magicBonus} é­”æ³•å‚·å®³ï¼ˆè€ç·´è€å±è‚¡ï¼‰`;
                log(txt + 'ã€‚');
            });
            log(`ğŸ”¢ åˆè¨ˆï¼š${totalDamage} é»å‚·å®³ã€‚`);
        } else {
            // å–®æ“Šæ™®é€šæƒ…æ³ï¼Œä¿ç•™åŸæœ¬ç°¡å–®é¢¨æ ¼
        }

        // å¸è¡€
        if (isPhysical && wAff.has('W_LIFESTEAL') && totalDamage > 0) {
            const heal = Math.max(1, Math.floor(totalDamage * 0.2));
            hero.hp = Math.min(hero.maxHp, hero.hp + heal);
            log(`ğŸ©¸ã€Œæ„›åƒä¸è¾£çš„(Blood)ã€ç”Ÿæ•ˆï¼Œå›å¾© ${heal} é» HPï¼`);
        }

        return totalDamage;
    }

    function tryTriggerMagicGuard() {
        const shield = hero.equipment.SHIELD;
        if (shield && shield.affixes && shield.affixes.includes('S_MAGIC_GUARD')) {
            if (Math.random() < 0.2) {
                hero.magicGuardTurns = 3;
                log('âœ¨ã€Œé­”æ³•èƒ¸ç½©ã€å•Ÿå‹•ï¼æ¥ä¸‹ä¾† 3 å›åˆå—åˆ°çš„å‚·å®³æ¸›åŠã€‚');
            }
        }
    }

    function doShieldStrikeFollowUp(label) {
        if (!currentEnemy || currentEnemy.hp <= 0) return 0;
        const SHIELD_DMG = Math.max(1, hero.currentDefense);
        if (enemyDodged('ğŸ›¡ï¸')) {
            log(`ğŸ˜ˆ ${currentEnemy.name} é–ƒéäº†ä½ çš„è¿½åŠ ç›¾æ“Šï¼`);
            return 0;
        }
        let dmg = applyHeroAttackEffects(SHIELD_DMG, true, 'SHIELD', label || 'ç›¾æ“Šè¿½æ‰“');
        currentEnemy.hp -= dmg;
        maybeExtraOverflowAttack('ç›¾æ“Šè¿½æ“Š');
        updateBattleView();
        return dmg;
    }

    function doSwordStrikeFollowUp(label) {
        if (!currentEnemy || currentEnemy.hp <= 0) return 0;
        const wAff = getAllWeaponAffixSet();
        let enemyDefForSword = currentEnemy.def || 0;
        if (wAff.has('W_ARMOR_PEN')) {
            enemyDefForSword = Math.floor(enemyDefForSword * 0.7);
        }
        let atkForCalc = hero.currentAttack;
        if (hero.buffDamageUpTurns > 0 && hero.buffDamageUpRate > 0) {
            atkForCalc = Math.floor(atkForCalc * (1 + hero.buffDamageUpRate));
        }
        let baseSwordDmg = Math.max(1, atkForCalc - enemyDefForSword);
        if (enemyDodged('âš”ï¸')) {
            log(`ğŸ˜ˆ ${currentEnemy.name} é–ƒéäº†ä½ çš„è¿½åŠ ç æ“Šï¼`);
            return 0;
        }
        let dmg = applyHeroAttackEffects(baseSwordDmg, true, 'SWORD', label || 'é¡å¤–ç æ“Š');
        currentEnemy.hp -= dmg;
        maybeExtraOverflowAttack('é¡å¤–ç æ“Šè¿½æ“Š');
        updateBattleView();
        return dmg;
    }

    function triggerBlockFollowUps() {
        const shield = hero.equipment.SHIELD;
        if (!shield || !shield.affixes) return;

        if (shield.affixes.includes('S_BLOCK_STRIKE')) {
            const dmg = doShieldStrikeFollowUp('æˆ‘å†é ‚~ğŸ’¥');
            if (dmg > 0) {
                log(`ğŸ›¡ï¸ã€Œæˆ‘å†é ‚~ğŸ’¥ã€è¿½åŠ ç›¾æ“Šé€ æˆ ${dmg} é»å‚·å®³ï¼`);
            }
        }
        if (shield.affixes.includes('S_BLOCK_CRIT')) {
            const dmg2 = doSwordStrikeFollowUp('æˆ‘å†ç ~ğŸ”ª');
            if (dmg2 > 0) {
                log(`âš”ï¸ã€Œæˆ‘å†ç ~ğŸ”ªã€è£œä¸Šä¸€åˆ€é€ æˆ ${dmg2} é»å‚·å®³ï¼`);
            }
        }
    }

    function applyDamageToHero(rawDamage, isBoss = false) {
        let dmg = rawDamage;
        const shield = hero.equipment.SHIELD;
        let blocked = false;

        if (hero.magicGuardTurns && hero.magicGuardTurns > 0) {
            dmg = Math.floor(dmg * 0.5);
            hero.magicGuardTurns--;
            if (hero.magicGuardTurns === 0) {
                log('ğŸ”š é­”åŠ›èƒ¸ç½©æ•ˆæœçµæŸã€‚');
            }
        }

        if (shield && shield.affixes && shield.affixes.includes('S_BLOCK')) {
            if (Math.random() < 0.2) {
                dmg = Math.floor(dmg * 0.5);
                blocked = true;
                log('ğŸ›¡ï¸ã€Œæˆ‘æ“‹~ğŸ›¡ï¸ã€æ ¼æ“‹æˆåŠŸï¼Œæœ¬æ¬¡å‚·å®³æ¸›åŠã€‚');
            }
        }

        if (shield && shield.affixes) {
            if (isBoss && shield.affixes.includes('S_BOSS_GUARD')) {
                dmg = Math.floor(dmg * 0.9);
                log('ğŸ‘‘ã€Œç™¢ç™¢æ»´ã€ç”Ÿæ•ˆï¼šå° Boss å‚·å®³ç•¥ç‚ºé™ä½ã€‚');
            }
            if (!isBoss && shield.affixes.includes('S_SMALL_GUARD')) {
                dmg = Math.floor(dmg * 0.95);
                log('ğŸ€ã€Œä¸å¤ªç—›ã€ç”Ÿæ•ˆï¼šä¸€èˆ¬å°æ€ªæ‰“ä½ æœ‰é»ä¸ç—›ã€‚');
            }
            if (shield.affixes.includes('S_REFLECT') && dmg > 0) {
                const reflect = Math.max(1, Math.floor(dmg * 0.2));
                currentEnemy.hp -= reflect;
                log(`ğŸ”ã€Œæ€éº¼åˆºåˆºçš„ã€åå½ˆ ${reflect} é»å‚·å®³çµ¦ ${currentEnemy.name}ï¼`);
            }
        }

        const final = Math.max(1, Math.floor(dmg));
        hero.hp -= final;

        if (blocked) {
            healFromLifeRing('BLOCK');
            triggerBlockFollowUps();
        }

        return final;
    }

    function enemyDodged(playerMove) {
        if (playerMove === 'ğŸ›¡ï¸') return false;
        const dodge = currentEnemy.dodge || 0;
        return Math.random() * 100 < dodge;
    }

    function applyHeroOngoingStatusAtTurnStart() {
        let heroDied = false;

        if (hero.burnTurns > 0 && hero.burnDamage > 0) {
            const dmg = hero.burnDamage;
            hero.hp -= dmg;
            hero.burnTurns--;
            log(`ğŸ”¥ ç¼ç‡’æŒçºŒç™¼ä½œï¼Œä½ å—åˆ° ${dmg} é»å‚·å®³ï¼ï¼ˆå‰©é¤˜ ${hero.burnTurns} å›åˆï¼‰`);
            flashBattleView('monster-hit');
            if (hero.burnTurns === 0) {
                hero.burnDamage = 0;
                log('ğŸ’§ ç¼ç‡’æ•ˆæœè§£é™¤ã€‚');
            }
            if (hero.hp <= 0) {
                hero.hp = 0;
                heroDied = true;
            }
        }

        if (hero.regenTurns > 0 && hero.regenAmount > 0 && hero.hp > 0) {
            const missing = hero.maxHp - hero.hp;
            if (missing > 0) {
                const heal = Math.min(hero.regenAmount, missing);
                hero.hp += heal;
                hero.regenTurns--;
                log(`ğŸ€ æŒçºŒå›å¾©æ•ˆæœï¼šæ¢å¾© ${heal} HPï¼ˆå‰©é¤˜ ${hero.regenTurns} å›åˆï¼‰ã€‚`);
                flashBattleView('heal');
            } else {
                hero.regenTurns--;
            }
            if (hero.regenTurns === 0) {
                hero.regenAmount = 0;
                log('ğŸ§¾ æŒçºŒå›å¾©æ•ˆæœçµæŸã€‚');
            }
        }

        if (hero.defDownTurns > 0) {
            hero.defDownTurns--;
            if (hero.defDownTurns === 0) {
                hero.defDownRate = 0;
                log('ğŸ›¡ï¸ é˜²ç¦¦åŠ›çš„è©›å’’è§£é™¤ï¼Œä½ çš„é˜²ç¦¦æ¢å¾©æ­£å¸¸ã€‚');
            }
        }

        if (hero.buffDamageUpTurns > 0) {
            hero.buffDamageUpTurns--;
            if (hero.buffDamageUpTurns === 0) {
                hero.buffDamageUpRate = 0;
                log('ğŸ’¥ å¥¶æ²¹æ³•å¸«åŠ æŒçš„ã€Œå‚·å®³ buffã€æ™‚é–“åˆ°äº†ï¼Œè¼¸å‡ºå›æ­¸æ­£å¸¸ã€‚');
            }
        }

        updateStatus();
        return heroDied;
    }

    function calcBossAttackDamage(baseDamage) {
        if (!currentEnemy) {
            return { damage: baseDamage, skip: false };
        }

        if (currentEnemy.name === 'é å¤é­”ç¥') {
            if (currentEnemy.ancientChargeState === 'CHARGING') {
                currentEnemy.ancientChargeState = null;
                const dmg = Math.max(1, baseDamage * 2);
                log('âš¡ é å¤é­”ç¥é‡‹æ”¾ã€è“„åŠ›é‡æ“Šã€‘ï¼Œé€ æˆ 2 å€å‚·å®³ï¼');
                return { damage: dmg, skip: false };
            }

            if (!currentEnemy.ancientChargeState && Math.random() < 0.25) {
                currentEnemy.ancientChargeState = 'CHARGING';
                log('ğŸ’¥ é å¤é­”ç¥é–‹å§‹è“„åŠ›ï¼Œæº–å‚™åœ¨ä¸‹ä¸€å›åˆä½¿å‡ºã€è“„åŠ›é‡æ“Šã€‘ï¼æœ¬å›åˆä¸æ”»æ“Šã€‚');
                return { damage: 0, skip: true };
            }
        }

        return { damage: baseDamage, skip: false };
    }

    function applyBossPostHitEffects(finalDamage) {
        if (!currentEnemy || finalDamage <= 0) return;

        if (currentEnemy.name === 'å“¥å¸ƒæ—') {
            if (Math.random() < 0.20) {
                const extra = Math.max(1, Math.floor(finalDamage * 0.3));
                hero.hp = Math.max(0, hero.hp - extra);
                log(`ğŸ—¡ï¸ å“¥å¸ƒæ—è¶äº‚å·è¥²ï¼Œå†é€ æˆ ${extra} é»é¡å¤–å‚·å®³ï¼`);
            }
        } else if (currentEnemy.name === 'éª·é«å…µ') {
            if (Math.random() < 0.20) {
                hero.defDownTurns = 2;
                hero.defDownRate = 0.15;
                log('ğŸ¦´ éª·é«å…µæ•²ç¢ä½ çš„è­·ç”²ï¼Œæœªä¾† 2 å›åˆé˜²ç¦¦åŠ›é™ä½ 15%ã€‚');
            }
        } else if (currentEnemy.name === 'é‡ç‹¼') {
            if (Math.random() < 0.25) {
                const extra = Math.max(1, Math.floor(finalDamage * 0.5));
                hero.hp = Math.max(0, hero.hp - extra);
                log(`ğŸº é‡ç‹¼è¶å‹¢å†å’¬ä¸€å£ï¼Œé¡å¤–é€ æˆ ${extra} é»å‚·å®³ï¼`);
            }
        } else if (currentEnemy.name === 'çŸ³é ­äºº') {
            if (Math.random() < 0.20) {
                const oldDef = currentEnemy.def || 0;
                const addDef = Math.max(1, Math.floor(oldDef * 0.1));
                currentEnemy.def = oldDef + addDef;
                log(`ğŸª¨ çŸ³é ­äººå•Ÿå‹•ã€ç¡¬åŒ–ã€‘ï¼Œé˜²ç¦¦åŠ›æ°¸ä¹…æå‡ ${addDef} é»ï¼ˆæœ¬å ´æˆ°é¬¥ï¼‰ã€‚`);
            }
        } else if (currentEnemy.name === 'è™è ') {
            if (Math.random() < 0.20) {
                const heal = Math.max(1, Math.floor(finalDamage * 0.3));
                currentEnemy.hp = Math.min(currentEnemy.originalHp, currentEnemy.hp + heal);
                log(`ğŸ¦‡ è™è å¸é£Ÿä½ çš„é®®è¡€ï¼Œå›å¾© ${heal} é» HPã€‚`);
            }
        } else if (currentEnemy.name === 'ä¸æ­»å·«å¦–') {
            if (Math.random() < 0.25) {
                const heal = Math.max(1, Math.floor(finalDamage * 0.15));
                currentEnemy.hp = Math.min(currentEnemy.originalHp, currentEnemy.hp + heal);
                log(`ğŸ©¸ ä¸æ­»å·«å¦–å¾ä½ çš„ç”Ÿå‘½ä¸­æ±²å–åŠ›é‡ï¼Œå›å¾© ${heal} HPã€‚`);
            }
            if (Math.random() < 0.20) {
                hero.defDownTurns = 3;
                hero.defDownRate = 0.20;
                log('ğŸ•¯ï¸ ä¸æ­»å·«å¦–çš„è©›å’’å‰Šå¼±äº†ä½ çš„è­·ç”²ï¼Œæœªä¾† 3 å›åˆé˜²ç¦¦åŠ›é™ä½ 20%ã€‚');
            }
        } else if (currentEnemy.name === 'ç«ç„°å·¨é¾') {
            if (Math.random() < 0.25) {
                const burnDmg = Math.max(1, Math.floor(hero.maxHp * 0.03));
                hero.burnTurns = 3;
                hero.burnDamage = burnDmg;
                log(`ğŸ”¥ ç«ç„°å·¨é¾çš„é¾ç‚é™„è‘—åœ¨ä½ èº«ä¸Šï¼Œæœªä¾† 3 å›åˆé–‹å§‹æ™‚æœƒå„æå¤± ${burnDmg} HPï¼`);
            }
            if (Math.random() < 0.25) {
                hero.defDownTurns = 2;
                hero.defDownRate = 0.25;
                log('ğŸ’¢ ç«ç„°å·¨é¾çš„é‡æ“Šç ¸è£‚äº†ä½ çš„è­·ç”²ï¼Œæœªä¾† 2 å›åˆé˜²ç¦¦åŠ›é™ä½ 25%ã€‚');
            }
        } else if (currentEnemy.name === 'é å¤é­”ç¥' || currentEnemy.name.includes('å°é­”ç¥')) {
            if (Math.random() < 0.30) {
                hero.defDownTurns = 2;
                hero.defDownRate = 0.30;
                log('ğŸ•³ï¸ é å¤é­”ç¥æ–½æ”¾ã€è™›ç©ºä¾µè•ã€‘ï¼Œæœªä¾† 2 å›åˆä½ çš„é˜²ç¦¦åŠ›é™ä½ 30%ã€‚');
            }
            if (Math.random() < 0.25) {
                const heal = Math.max(1, Math.floor(finalDamage * 0.25));
                currentEnemy.hp = Math.min(currentEnemy.originalHp, currentEnemy.hp + heal);
                log(`ğŸ©¸ é å¤é­”ç¥å¾ä½ çš„ç—›è‹¦ä¸­æ±²å–åŠ›é‡ï¼Œå›å¾© ${heal} HPã€‚`);
            }
        }
    }

    function maybeExtraOverflowAttack(label) {
        const ring = hero.equipment.RING;
        if (!ring || !ring.ability || ring.ability.id !== 'DODGE') return;
        if (!currentEnemy || currentEnemy.hp <= 0) return;
        if (hero.dodgeOverflow <= 0) return;

        const chance = hero.dodgeOverflow / 100;
        if (Math.random() >= chance) return;

        log(`ğŸ’¨ é–ƒé¿æº¢å‡ºè¿½æ“Šç™¼å‹•ï¼ï¼ˆæ©Ÿç‡ç´„ ${hero.dodgeOverflow.toFixed(1)}%ï¼‰`);
        doSwordStrikeFollowUp(label || 'è¿½æ“Šç æ“Š');
    }

    function heroDodgeCounterAttack() {
        if (!currentEnemy || currentEnemy.hp <= 0) return;
        log('ğŸ’¥ æ•æ·åæ“Šï¼šä½ è¶è‘—é–ƒé¿çš„ç©ºæª”è£œä¸Šä¸€åˆ€ï¼');
        const dmg = doSwordStrikeFollowUp('é–ƒé¿åæ“Š');
        if (currentEnemy.hp <= 0 && dmg > 0) {
            setTimeout(() => endBattle('win'), 800);
        }
    }

    function monsterAttack(monsterMove) {
        const ring = hero.equipment.RING;
        if (ring && ring.ability && ring.ability.id === 'DODGE' &&
            Math.random() * 100 < hero.currentDodge) {

            log(`ğŸ’¨ æ•æ·æŒ‡ç’°ï¼šæˆåŠŸé–ƒé¿äº† ${currentEnemy.name} çš„æ”»æ“Šï¼`);
            flashBattleView('heal');
            heroDodgeCounterAttack();
            return;
        }

        let monsterDamage = Math.max(1, currentEnemy.atk - hero.currentDefense);

        const bossNames = ENEMIES.BOSS.map(b => b.name);
        const isBoss = bossNames.includes(currentEnemy.name);

        const bossAttack = calcBossAttackDamage(monsterDamage);
        if (bossAttack.skip) {
            return;
        }
        monsterDamage = bossAttack.damage;

        const finalDamage = applyDamageToHero(monsterDamage, isBoss);
        log(`ğŸ’¥ ${currentEnemy.name} ${monsterMove} æ”»æ“Šï¼Œé€ æˆ ${finalDamage} é»å‚·å®³!`);
        flashBattleView('monster-hit');

        applyBossPostHitEffects(finalDamage);
    }

    async function handleBattleAction(playerMove) {
        if (gameState !== 'BATTLE') return;
        totalTurnCount++;   // æ¯ä¸€å›åˆæˆ°é¬¥ä¹Ÿç®— 1 å›åˆ
        disableCommands(true);
        let battleEnded = false;

        try {
            if (applyHeroOngoingStatusAtTurnStart()) {
                updateStatus();
                setTimeout(() => endBattle('lose'), 1000);
                return;
            }

            const bias = currentEnemy.bias;
            let monsterMove = '';
            const r = Math.random();
            let cumulative = 0;
            if (r < (cumulative += bias['âš”ï¸'])) monsterMove = 'âš”ï¸';
            else if (r < (cumulative += bias['ğŸŒ '])) monsterMove = 'ğŸŒ ';
            else monsterMove = 'ğŸ›¡ï¸';

            log(`--- é›™æ–¹åŒæ™‚å‡ºæ‹› ---`);
            log(`å‹‡è€…å‡ºæ‹›: ${playerMove} | æ€ªç‰©å‡ºæ‹›: ${monsterMove}`);

            const isHeroWin    = CLASH_RULES[playerMove] === monsterMove;
            const isMonsterWin = CLASH_RULES[monsterMove] === playerMove;

            const wAff = getAllWeaponAffixSet();
            let enemyDefForSword = currentEnemy.def || 0;
            if (wAff.has('W_ARMOR_PEN')) {
                enemyDefForSword = Math.floor(enemyDefForSword * 0.7);
            }

            let atkForCalc = hero.currentAttack;
            let magicForCalc = getMagicAttackValue();
            if (hero.buffDamageUpTurns > 0 && hero.buffDamageUpRate > 0) {
                atkForCalc = Math.floor(atkForCalc * (1 + hero.buffDamageUpRate));
                magicForCalc = Math.floor(magicForCalc * (1 + hero.buffDamageUpRate));
            }

            let baseSwordDmg  = Math.max(1, atkForCalc - enemyDefForSword);
            let baseMagicDmg  = Math.max(1, magicForCalc - (currentEnemy.mDef || currentEnemy.def || 0));
            const SHIELD_DMG  = Math.max(1, hero.currentDefense);

            if (isHeroWin) {
                let damage = 0;
                let isPhysical = false;
                let attackKind = null;

                if (playerMove === 'âš”ï¸') {
                    damage = baseSwordDmg;
                    isPhysical = true;
                    attackKind = 'SWORD';
                } else if (playerMove === 'ğŸŒ ') {
                    damage = baseMagicDmg;
                    isPhysical = false;
                    attackKind = 'MAGIC';
                } else if (playerMove === 'ğŸ›¡ï¸') {
                    damage = SHIELD_DMG;
                    isPhysical = true;
                    attackKind = 'SHIELD';
                    if (currentEnemy.name === 'çŸ³é ­äºº') {
                        damage *= 2;
                        log('ğŸ’¥ çŸ³é ­äººç‰¹åˆ¥æ€•ç›¾æ“Šï¼Œç›¾æ“Šå‚·å®³åŠ å€ï¼');
                    }
                }

                if (enemyDodged(playerMove)) {
                    log(`ğŸ˜ˆ ${currentEnemy.name} æˆåŠŸé–ƒé¿äº†ä½ çš„æ”»æ“Šï¼`);
                    damage = 0;
                } else {
                    if (isPhysical && damage > 0) {
                        damage = applyHeroAttackEffects(damage, true, attackKind, 'ä¸»å‹•æ”»æ“Š');
                    } else if (!isPhysical && damage > 0) {
                        // é å¤é­”ç¥è¢«é­”æ”»æ™‚æœƒåå™¬è‡ªå·±ï¼ˆç•¶æˆå¢å‚·ï¼‰
                        if (currentEnemy.name === 'é å¤é­”ç¥') {
                            const extra = Math.max(1, Math.floor(getMagicAttackValue() * 0.1));
                            damage += extra;
                            log(`ğŸ§¿ é å¤é­”ç¥é­å—ä½ çš„é­”æ³•åå™¬ï¼Œé¡å¤–å¤šæ‰¿å— ${extra} é»å‚·å®³ï¼`);
                        }
                    }
                    if (playerMove === 'ğŸŒ ' || playerMove === 'ğŸ›¡ï¸') {
                        tryTriggerMagicGuard();
                    }
                    currentEnemy.hp -= damage;
                    log(`âœ… å‹‡è€…é€ æˆ ${damage} é»å‚·å®³!`);
                    flashBattleView('hero-hit');

                    if (playerMove === 'ğŸ›¡ï¸' && damage > 0) {
                        healFromLifeRing('SHIELD');
                    }
                    if (damage > 0) {
                        maybeExtraOverflowAttack('ä¸»å‹•è¿½æ“Š');
                    }
                }
            } else if (playerMove === monsterMove) {
                log(`ğŸ¤ é›™æ–¹å‡ºæ‹›ç›¸åŒ (${playerMove})ï¼Œé€²å…¥å¹³æ‰‹æ©Ÿç‡åˆ¤å®š!`);
                const tieWinChance = hero.currentTieWinRate / 100;
                if (Math.random() < tieWinChance) {
                    log(`âœ¨ åˆ¤å®šæˆåŠŸ! å‹‡è€…ç²å¾—å„ªå‹¢!`);

                    let damage = 0;
                    let isPhysical = false;
                    let attackKind = null;

                    if (playerMove === 'âš”ï¸') {
                        damage = baseSwordDmg;
                        isPhysical = true;
                        attackKind = 'SWORD';
                    } else if (playerMove === 'ğŸŒ ') {
                        damage = baseMagicDmg;
                        isPhysical = false;
                        attackKind = 'MAGIC';
                    } else if (playerMove === 'ğŸ›¡ï¸') {
                        damage = SHIELD_DMG;
                        isPhysical = true;
                        attackKind = 'SHIELD';
                        if (currentEnemy.name === 'çŸ³é ­äºº') {
                            damage *= 2;
                            log('ğŸ’¥ çŸ³é ­äººç‰¹åˆ¥æ€•ç›¾æ“Šï¼Œç›¾æ“Šå‚·å®³åŠ å€ï¼');
                        }
                    }

                    if (enemyDodged(playerMove)) {
                        log(`ğŸ˜ˆ ${currentEnemy.name} åœ¨å¹³æ‰‹åˆ¤å®šä¸­æˆåŠŸé–ƒé¿ä½ çš„æ”»æ“Šï¼`);
                        damage = 0;
                    } else {
                        if (isPhysical && damage > 0) {
                            damage = applyHeroAttackEffects(damage, true, attackKind, 'å¹³æ‰‹å„ªå‹¢æ”»æ“Š');
                        } else if (!isPhysical && damage > 0) {
                            if (currentEnemy.name === 'é å¤é­”ç¥') {
                                const extra = Math.max(1, Math.floor(getMagicAttackValue() * 0.1));
                                damage += extra;
                                log(`ğŸ§¿ é å¤é­”ç¥é­å—ä½ çš„é­”æ³•åå™¬ï¼Œé¡å¤–å¤šæ‰¿å— ${extra} é»å‚·å®³ï¼`);
                            }
                        }
                        if (playerMove === 'ğŸŒ ' || playerMove === 'ğŸ›¡ï¸') {
                            tryTriggerMagicGuard();
                        }
                        currentEnemy.hp -= damage;
                        log(`âœ… å‹‡è€…é€ æˆ ${damage} é»å‚·å®³!`);
                        flashBattleView('hero-hit');

                        if (playerMove === 'ğŸ›¡ï¸' && damage > 0) {
                            healFromLifeRing('SHIELD');
                        }
                        if (damage > 0) {
                            maybeExtraOverflowAttack('å¹³æ‰‹è¿½æ“Š');
                        }
                    }
                } else {
                    log(`ğŸ’€ åˆ¤å®šå¤±æ•—... æ€ªç‰©ç²å¾—å„ªå‹¢!`);
                    monsterAttack(monsterMove);
                }
            } else if (isMonsterWin) {
                log(`ğŸ¦¸â€â™‚ï¸ å‹‡è€… ${playerMove} è¢« ${monsterMove} å…‹åˆ¶ï¼Œæ‹›å¼è¢«æ“‹é–‹ã€‚`);
                if (playerMove === 'ğŸ›¡ï¸' && monsterMove === 'âš”ï¸') {
                    let damage = SHIELD_DMG;
                    let attackKind = 'SHIELD';
                    if (currentEnemy.name === 'çŸ³é ­äºº') {
                        damage *= 2;
                        log('ğŸ’¥ çŸ³é ­äººç‰¹åˆ¥æ€•ç›¾æ“Šï¼Œç›¾æ“Šå‚·å®³åŠ å€ï¼');
                    }
                    if (enemyDodged('ğŸ›¡ï¸')) {
                        log(`ğŸ˜ˆ ${currentEnemy.name} é–ƒéäº†ä½ çš„ç›¾æ“Šåæ“Šï¼`);
                        damage = 0;
                    } else {
                        damage = applyHeroAttackEffects(damage, true, attackKind, 'ç›¾æ“Šåæ“Š');
                        tryTriggerMagicGuard();
                        currentEnemy.hp -= damage;
                        log(`ğŸ’¥ ç›¾æ“Šåæ“Š! é€ æˆ ${damage} é»å‚·å®³ã€‚`);
                        flashBattleView('hero-hit');
                        if (damage > 0) {
                            healFromLifeRing('SHIELD');
                            maybeExtraOverflowAttack('ç›¾æ“Šåæ“Šè¿½æ“Š');
                        }
                    }
                } else {
                    monsterAttack(monsterMove);
                }
            }

            updateBattleView();
            if (currentEnemy.hp <= 0) {
                setTimeout(() => endBattle('win'), 1500);
                battleEnded = true;
                return;
            }

            await new Promise(resolve => setTimeout(resolve, 800));

            if (!isHeroWin && !(playerMove === monsterMove && Math.random() < hero.currentTieWinRate / 100) && !isMonsterWin) {
                // å·²ç”±ä¸Šé¢çš„åˆ†æ”¯è™•ç†ï¼Œé€™è£¡ä¸å†é‡è¤‡æ”»æ“Š
            }

            updateStatus();
            if (hero.hp <= 0) {
                setTimeout(() => endBattle('lose'), 1500);
                battleEnded = true;
                return;
            }
        } finally {
            if (!battleEnded && gameState === 'BATTLE') {
                disableCommands(false);
            }
        }
    }

    function gainExp(amount) {
        if (hero.level >= MAX_LEVEL) return;
        hero.exp += amount;
        log(`ç²å¾—äº† ${amount} é»ç¶“é©—å€¼!`);

        while (hero.exp >= hero.expToNextLevel && hero.level < MAX_LEVEL) {
            hero.exp -= hero.expToNextLevel;
            levelUp();
        }
        updateStatus();
    }

    function levelUp() {
        if (hero.level >= MAX_LEVEL) return;
        const oldLevel = hero.level;
        hero.level++;
        hero.expToNextLevel = Math.floor(hero.expToNextLevel * 1.15) + 3;

        if (hero.level > hero.highestLevel) {
            hero.highestLevel = hero.level;

            hero.maxHp += HP_PER_LEVEL;
            const atkGain   = randInt(1, 3);
            const defGain   = randInt(1, 3);
            const dodgeGain = randInt(0, 2);   // é–ƒé¿æˆé•·ç¸®å°ï¼Œé¿å…å¤ªèª‡å¼µ
            const tieGain   = randInt(1, 3);
            const matkGain  = randInt(3, 5);

            hero.baseAttack     += atkGain;
            hero.baseDefense    += defGain;
            hero.baseDodge      += dodgeGain;
            hero.baseTieWinRate += tieGain;
            hero.baseMagicAtk   += matkGain;

            hero.hp = hero.maxHp;
            log(`ğŸ‰ å‡ç´š! Lv.${oldLevel} â†’ Lv.${hero.level} (é¦–æ¬¡é”åˆ°è©²ç­‰ç´š)`);
            log(`   HP +${HP_PER_LEVEL}ï¼ŒATK +${atkGain}ï¼ŒDEF +${defGain}ï¼Œé–ƒé¿ +${dodgeGain}% ï¼Œå¹³æ‰‹å‹ç‡ +${tieGain}% ï¼ŒMATK +${matkGain}`);
        } else {
            hero.maxHp += HP_PER_LEVEL;
            hero.hp = hero.maxHp;
            log(`â¬†ï¸ å›åˆ°æ›¾ç¶“åˆ°éçš„ç­‰ç´š Lv.${hero.level}ï¼Œåªæ¢å¾©æœ€å¤§ HPï¼Œä¸å†è¿½åŠ èƒ½åŠ›æˆé•·ã€‚`);
        }
    }

    function unlockNewRarity() {
        if (bossLevel === 2) {
            log(`ğŸ‰ å·²æ“Šæ•— Boss 1ï¼šé–‹å§‹æœ‰æ©Ÿæœƒæ‰è½ <span class="${RARITY_COLORS['Legendary']}">æ©˜æ­¦ã€æ©˜ç›¾</span>ï¼`);
        } else if (bossLevel === 3) {
            log(`ğŸ‰ å·²æ“Šæ•— Boss 2ï¼šé–‹å§‹æœ‰æ©Ÿæœƒæ‰è½ <span class="${RARITY_COLORS['Mythic']}">ç´…æ­¦ã€ç´…ç›¾</span>ï¼`);
        }
    }

//é€šé—œæ™‚æŠŠè§’è‰²å¿«ç…§å­˜åˆ° localStorage
            function recordClearRun() {
            const snapshot = {
                title: hero.name,
                level: hero.level,
                maxHp: hero.maxHp,
                baseAttack: hero.baseAttack,
                baseDefense: hero.baseDefense,
                baseMagicAtk: hero.baseMagicAtk,
                currentAttack: hero.currentAttack,
                currentDefense: hero.currentDefense,
                currentMagicAtk: getMagicAttackValue(),
                ring: hero.equipment.RING,
                weapon: hero.equipment.WEAPON,
                shield: hero.equipment.SHIELD,
                totalTurn: totalTurnCount,
                time: Date.now()
            };
        
            let list = [];
            try {
                list = JSON.parse(localStorage.getItem('clearRecords') || '[]');
            } catch (e) {
                list = [];
            }
        
            list.push(snapshot);
            // è¶Šå°‘å›åˆè¶Šå‰é¢
            list.sort((a, b) => a.totalTurn - b.totalTurn);
            // åªç•™å‰ 10 å
            list = list.slice(0, 10);
        
            localStorage.setItem('clearRecords', JSON.stringify(list));
        
            log(`ğŸ“’ å·²å°‡ä½ çš„é€šé—œç´€éŒ„å­˜å…¥å‰ 10 åå€™è£œï¼ˆç›®å‰å›åˆï¼š${snapshot.totalTurn}ï¼‰ã€‚`);
        }


    function showCredits() {
        gameState = 'CREDITS';
        disableCommands(true);
        mainView.style.backgroundColor = '#000';
        mainView.style.whiteSpace = 'pre-wrap';
        mainView.innerHTML = `
ğŸ‰ å²è©©ç´šå‹åˆ©ï¼ä¸–ç•Œæ¢å¾©äº†å’Œå¹³ ğŸ‰

ã€ä¸–ç•Œå’Œå¹³è¨ˆç•« - æœ€çµ‚è£½ä½œåå–®ã€‘

éŠæˆ²æ¦‚å¿µ / åŸå‰µä½œè€…ï¼šJack
ç¸½ç›£ (Director)ï¼šJack
ç¨‹å¼ç¢¼æ’°å¯« (Code)ï¼šJack
ç¾è¡“è¨­è¨ˆ (ASCII Art)ï¼šJack
éŠæˆ²å¹³è¡¡ / æ•¸å€¼ (Balance)ï¼šJack

ç‰¹åˆ¥æ„Ÿè¬ï¼šæ­£åœ¨ç©é€™å€‹ç¶²é çš„ä½ 

ï¼ˆ25 ç§’å¾Œè‡ªå‹•å›åˆ°åœ°åœ–ç•«é¢ï¼Œç¹¼çºŒæ‰“å¯¶ï¼‰`;

        setTimeout(() => {
            enterMap();
        }, 25000);
    }

    async function endBattle(result) {
        disableCommands(true);
        currentEnemy.hp = Math.max(0, currentEnemy.hp);

        if (result === "win") {
            const expGained = currentEnemy.exp;
            gainExp(expGained);
            log(`ğŸ† æ“Šæ•—äº† ${currentEnemy.name}!`);

            const isBoss = ENEMIES.BOSS.some(b => b.name === currentEnemy.name);
            if (isBoss) {
                if (bossLevel <= ENEMIES.BOSS.length) {
                    unlockNewRarity();
                    bossLevel++;
                    if (bossLevel <= ENEMIES.BOSS.length) {
                        log(`ğŸ‰ æ–°çš„æŒ‘æˆ°è§£é–! Boss ${bossLevel} å¯¶è—å·²é–‹å•Ÿ!`);
                    }
                }
                if (bossLevel > ENEMIES.BOSS.length) {
                    log("ğŸ‘‘ æ­å–œ! ä½ æ“Šæ•—äº†æ‰€æœ‰ Bossï¼Œä¸–ç•Œæ¢å¾©äº†å’Œå¹³!");
                    showCredits();
                    return;
                }
            }

            await handleLootDrop(currentEnemy, isBoss);
        } else if (result === "lose") {
            log("ğŸ’€ å‹‡è€…å€’ä¸‹äº†... ä½ çš„å†’éšªæš«æ™‚å‘Šä¸€æ®µè½ã€‚");
            applyDeathPenalty();
        }

        const isFinalBoss = result === 'win' &&
            ENEMIES.BOSS.length > 0 &&
            currentEnemy.name === ENEMIES.BOSS[ENEMIES.BOSS.length - 1].name;
        
        if (isFinalBoss) {
            // é€šé—œæ™‚è¨˜éŒ„ä¸€æ¬¡è§’è‰²è³‡æ–™
            recordClearRun();
        }
        
        if (!isFinalBoss && gameState !== 'LOOT_RING_DECISION' && gameState !== 'CREDITS') {
            setTimeout(enterMap, 2000);
        }

    }

    function applyDeathPenalty() {
        if (hero.level === 1) {
            log("å¹¸é‹çš„æ˜¯ï¼Œæ–°æ‰‹éšæ®µä¸æœƒå—åˆ°æ­»äº¡æ‡²ç½°ã€‚");
            hero.hp = hero.maxHp;
            updateStatus();
            setTimeout(enterMap, 2000);
            return;
        }
        const expLoss = Math.floor(hero.expToNextLevel * 0.5);
        hero.exp -= expLoss;
        log(`âš¡ å› æˆ°æ•—ï¼Œä½ æå¤±äº† ${expLoss} é»ç¶“é©—å€¼ã€‚`);

        if (hero.exp < 0) {
            log(`ğŸ”¥ ç¶“é©—å€¼ä¸è¶³! å‹‡è€…é™ç´šäº†!`);
            const oldLevel = hero.level;
            hero.level = Math.max(1, hero.level - 1);

            let currentExpToNext = 10;
            let tempLevel = 2;
            while (tempLevel <= hero.level) {
                currentExpToNext = Math.floor(currentExpToNext * 1.15) + 3;
                tempLevel++;
            }
            hero.expToNextLevel = currentExpToNext;
            hero.exp = Math.max(0, hero.expToNextLevel + hero.exp);

            hero.maxHp = Math.max(HERO_MAX_HP_START + (hero.level - 1) * HP_PER_LEVEL, HERO_MAX_HP_START);
            hero.hp = hero.maxHp;
            log(`â¬‡ï¸ ç­‰ç´šå¾ Lv.${oldLevel} é™åˆ° Lv.${hero.level}ï¼Œæœ€å¤§ HP è·Ÿè‘—é™ä½ï¼Œå…¶é¤˜èƒ½åŠ›ä¿ç•™ã€‚`);
        } else {
            hero.hp = hero.maxHp;
        }
        updateStatus();
        setTimeout(enterMap, 2000);
    }

            //ç¨±è™Ÿç¢ºèª & éš¨æ©ŸæŒ‰éˆ•
        function buildRandomTitle() {
            let aPart = TITLE_A[Math.floor(Math.random() * TITLE_A.length)];
            let bPart = TITLE_B[Math.floor(Math.random() * TITLE_B.length)];
            let cPart = TITLE_C[Math.floor(Math.random() * TITLE_C.length)];
            return `${aPart}çš„${bPart}${cPart}`;
        }
        
        // åªå–®ç´”æŠ½ä¸€çµ„çµ¦ç©å®¶çœ‹ï¼Œä¸é–‹å§‹éŠæˆ²
        function randomTitleOnly() {
            const title = buildRandomTitle();
            alert(`æŠ½åˆ°çš„ç¨±è™Ÿæ˜¯ï¼š\nã€Œ${title}ã€\nå¦‚æœå–œæ­¡ï¼Œå¯ä»¥è‡ªå·±å¾ä¸‹æ‹‰é¸å–®æŒ‘ä¸€æ¨£çš„çµ„åˆï¼›\nä¸æ”¹ç›´æ¥æŒ‰ã€Œé–‹å§‹å†’éšªã€æœƒå†é‡æŠ½ä¸€æ¬¡ã€‚`);
        }
        
        function confirmTitle() {
            const A = document.getElementById("titleA").value;
            const B = document.getElementById("titleB").value;
            const C = document.getElementById("titleC").value;
        
            let finalTitle;
        
            if (!A && !B && !C) {
                // ä¸‰å€‹éƒ½æ²’é¸ â†’ å®Œå…¨éš¨æ©Ÿ
                finalTitle = buildRandomTitle();
            } else {
                // æœ‰é¸å°±ç”¨ç©å®¶çš„é¸é …ï¼Œæ²’é¸çš„éƒ¨ä½ç”¨éš¨æ©Ÿè£œ
                let aPart = A || TITLE_A[Math.floor(Math.random() * TITLE_A.length)];
                let bPart = B || TITLE_B[Math.floor(Math.random() * TITLE_B.length)];
                let cPart = C || TITLE_C[Math.floor(Math.random() * TITLE_C.length)];
                finalTitle = `${aPart}çš„${bPart}${cPart}`;
            }
        
            hero.name = finalTitle;                     // è¨­å®šå‹‡è€…åç¨±
            localStorage.setItem("playerTitle", finalTitle);  // å­˜æª”çµ¦ä¹‹å¾Œç”¨
        
            // é—œæ‰é®ç½©
            document.getElementById("titleSelectBox").style.display = "none";
        
            log(`ğŸ§¾ ä½ çš„ç¨±è™Ÿæ˜¯ã€Œ${finalTitle}ã€ã€‚ç¥ä½ æ­¦é‹æ˜Œéš†ï¼`);
        
            // é–‹å§‹éŠæˆ²
            startGame();
        }


        // ===== ä¾ç­‰ç´šåˆ‡æ›æˆé•·éšæ®µ =====
        function getRandomRarity(lootType, isBoss = false) {
            
            let phase = 0;
            if (hero.level >= 8)  phase = 1;  // æˆé•·éšæ®µ 1
            if (hero.level >= 15) phase = 2;  // æˆé•·éšæ®µ 2
            if (hero.level >= 22) phase = 3;  // æˆé•·éšæ®µ 3
        
            // ===============================
            // ä¸€èˆ¬è£å‚™ï¼ˆæ­¦å™¨ / ç›¾ç‰Œï¼‰æ‰è½è¡¨
            // ç­‰ç´šè¶Šé«˜ â†’ ç°ç¶ ä¸‹é™ã€è—ç´«æ©˜ç´…ä¸Šå‡
            // ===============================
            const equipTable0 = [ // Lv 1â€“7ï¼šç°ç¶ ç‚ºä¸»
                { rarity: 'Normal',    weight: 45 },
                { rarity: 'Magic',     weight: 35 },
                { rarity: 'Rare',      weight: 15 },
                { rarity: 'Epic',      weight: 5  },
                { rarity: 'Legendary', weight: 0  },
                { rarity: 'Mythic',    weight: 0  }
            ];
            const equipTable1 = [ // Lv 8â€“14ï¼šé–‹å§‹çœ‹åˆ°ç´«
                { rarity: 'Normal',    weight: 30 },
                { rarity: 'Magic',     weight: 30 },
                { rarity: 'Rare',      weight: 25 },
                { rarity: 'Epic',      weight: 12 },
                { rarity: 'Legendary', weight: 3  },
                { rarity: 'Mythic',    weight: 0  }
            ];
            const equipTable2 = [ // Lv 15â€“21ï¼šç´«ç‚ºä¸»ï¼Œæ©˜é–‹å§‹å‡ºç¾
                { rarity: 'Normal',    weight: 15 },
                { rarity: 'Magic',     weight: 20 },
                { rarity: 'Rare',      weight: 30 },
                { rarity: 'Epic',      weight: 25 },
                { rarity: 'Legendary', weight: 8  },
                { rarity: 'Mythic',    weight: 2  }
            ];
            const equipTable3 = [ // Lv 22+ï¼šç´«æ©˜å¾ˆå¤šï¼Œç´…é–‹å§‹æ‰
                { rarity: 'Normal',    weight: 8  },
                { rarity: 'Magic',     weight: 12 },
                { rarity: 'Rare',      weight: 25 },
                { rarity: 'Epic',      weight: 30 },
                { rarity: 'Legendary', weight: 18 },
                { rarity: 'Mythic',    weight: 7  }
            ];
        
            // ===============================
            // æˆ’æŒ‡æ‰è½è¡¨ï¼ˆæœ¬ä¾†å°±æ¯”ä¸€èˆ¬è£å‚™æ›´é«˜ç¨€æœ‰ï¼‰
            // ä¸€æ¨£åˆ† 4 å€‹éšæ®µï¼Œä½†æ•´é«”åå‘ Rare ä»¥ä¸Š
            // ===============================
            const ringTable0 = [ // Lv 1â€“7
                { rarity: 'Normal',    weight: 25 },
                { rarity: 'Magic',     weight: 30 },
                { rarity: 'Rare',      weight: 25 },
                { rarity: 'Epic',      weight: 15 },
                { rarity: 'Legendary', weight: 5  },
                { rarity: 'Mythic',    weight: 0  }
            ];
            const ringTable1 = [ // Lv 8â€“14
                { rarity: 'Normal',    weight: 15 },
                { rarity: 'Magic',     weight: 25 },
                { rarity: 'Rare',      weight: 30 },
                { rarity: 'Epic',      weight: 20 },
                { rarity: 'Legendary', weight: 8  },
                { rarity: 'Mythic',    weight: 2  }
            ];
            const ringTable2 = [ // Lv 15â€“21
                { rarity: 'Normal',    weight: 10 },
                { rarity: 'Magic',     weight: 18 },
                { rarity: 'Rare',      weight: 28 },
                { rarity: 'Epic',      weight: 25 },
                { rarity: 'Legendary', weight: 14 },
                { rarity: 'Mythic',    weight: 5  }
            ];
            const ringTable3 = [ // Lv 22+
                { rarity: 'Normal',    weight: 6  },
                { rarity: 'Magic',     weight: 12 },
                { rarity: 'Rare',      weight: 24 },
                { rarity: 'Epic',      weight: 28 },
                { rarity: 'Legendary', weight: 20 },
                { rarity: 'Mythic',    weight: 10 }
            ];
        
            // ===== å…ˆä¾è£å‚™é¡å‹é¸ table =====
            let table;
        
            if (lootType === 'RING') {
                // æˆ’æŒ‡ç”¨æˆ’æŒ‡å°ˆç”¨è¡¨
                if      (phase === 0) table = ringTable0;
                else if (phase === 1) table = ringTable1;
                else if (phase === 2) table = ringTable2;
                else                  table = ringTable3;
            } else {
                // æ­¦å™¨ / ç›¾ç‰Œç”¨ä¸€èˆ¬è£å‚™è¡¨
                if      (phase === 0) table = equipTable0;
                else if (phase === 1) table = equipTable1;
                else if (phase === 2) table = equipTable2;
                else                  table = equipTable3;
            }
        
            // ===== Boss æ‰è½é¡å¤–åå‘é«˜ç¨€æœ‰ =====
            if (isBoss) {
                table = table.map(entry => {
                    let factor = 1;
                    switch (entry.rarity) {
                        case 'Normal':    factor = 0.5; break;  // ç°â†“
                        case 'Magic':     factor = 0.7; break;  // ç¶ â†“
                        case 'Rare':      factor = 1.0; break;
                        case 'Epic':      factor = 1.4; break;  // ç´«â†‘
                        case 'Legendary': factor = 1.8; break;  // æ©˜â†‘â†‘
                        case 'Mythic':    factor = 2.2; break;  // ç´…â†‘â†‘â†‘
                    }
                    return { ...entry, weight: entry.weight * factor };
                });
            }
        
            // ===== å¯¦éš›æŠ½é¸ =====
            const total = table.reduce((sum, e) => sum + e.weight, 0) || 1;
            let r = Math.random() * total;
            for (const e of table) {
                if (r < e.weight) return e.rarity;
                r -= e.weight;
            }
            return 'Normal';
        }


    function getPowerRange(rarity, isWeapon, isBoss) {
        const base = isWeapon ? 10 : 5;
        const multiplier = isWeapon ? 1.5 : 1;
        const bossBonus = isBoss ? hero.level * 0.5 : 0;
        switch (rarity) {
            case 'Mythic':   return { min: (base * 5.0 * multiplier) + bossBonus * 15, max: (base * 6.5 * multiplier) + bossBonus * 15 };
            case 'Legendary':return { min: (base * 4.0 * multiplier) + bossBonus * 10, max: (base * 5.0 * multiplier) + bossBonus * 10 };
            case 'Epic':     return { min: (base * 3.0 * multiplier) + bossBonus * 5,  max: (base * 4.0 * multiplier) + bossBonus * 5 };
            case 'Rare':     return { min: (base * 2.0 * multiplier) + bossBonus * 2,  max: (base * 3.0 * multiplier) + bossBonus * 2 };
            case 'Magic':    return { min: (base * 1.0 * multiplier) + bossBonus * 1,  max: (base * 2.0 * multiplier) + bossBonus * 1 };
            default:         return { min: base * 0.5 * multiplier, max: base * 1.0 * multiplier };
        }
    }

    function generateLoot(type, isBoss) {
        let rarity = getRandomRarity(type, isBoss);

        if (type === 'RING') {
            const abilityIndex = Math.floor(Math.random() * (RING_ABILITIES.length - 1));
            const ability = RING_ABILITIES[abilityIndex];
            let tier = 1;
            if (isBoss) tier = Math.min(4, bossLevel + 1);
            else tier = Math.min(2, Math.ceil(Math.random() * 2));
            return { type: 'RING', name: ability.name, ability: ability, tier: tier, rarity: rarity };
        }

        const isWeapon = type === 'WEAPON';
        const range = getPowerRange(rarity, isWeapon, isBoss);
        const power = Math.floor(Math.random() * (range.max - range.min) + range.min) + 1;
        const name = isWeapon ? `${rarity}ä¹‹åŠ` : `${rarity}ä¹‹ç›¾`;
        const equip = {
            type, name, power, rarity,
            refine: 0,
            refineSlots: 0,
            affixes: [],
        };

        const baseSlotsByRarity = {
            Normal: 0, Magic: 0, Rare: 1, Epic: 1, Legendary: 2, Mythic: 3
        };
        const baseSlots = baseSlotsByRarity[rarity] || 0;
        const pool = isWeapon ? WEAPON_AFFIX_POOL : SHIELD_AFFIX_POOL;
        for (let i = 0; i < baseSlots; i++) {
            addRandomAffix(equip, pool);
        }
        return equip;
    }

    async function handleLootDrop(enemy, isBoss) {
        if (Math.random() > enemy.lootChance) {
            log("ğŸ§± é€™æ¬¡æ€ªç‰©å¾ˆçª®ï¼Œå•¥éƒ½æ²’æ‰ã€‚");
            return;
        }
        const lootType = ['WEAPON', 'SHIELD', 'RING'][Math.floor(Math.random() * 3)];
        const loot = generateLoot(lootType, isBoss);
        await showLootAnimation(loot);

        log(`âœ¨ ${enemy.name} æ‰è½äº† <span class="${RARITY_COLORS[loot.rarity] || 'Rarity-Rare'}">${loot.name}</span>!`);

        if (lootType === 'RING') {
            const currentRing = hero.equipment.RING;
            if (currentRing.ability && currentRing.ability.id === loot.ability.id && currentRing.ability.id !== 'NONE') {
                if (currentRing.tier < 4) {
                    currentRing.tier = Math.min(4, currentRing.tier + 1);
                    if (RARITY_ORDER.indexOf(loot.rarity) > RARITY_ORDER.indexOf(currentRing.rarity)) {
                        currentRing.rarity = loot.rarity;
                    }
                    log(`ğŸ’ æ‰“åˆ°ç›¸åŒæˆ’æŒ‡ï¼š${currentRing.name} å‡ç´šç‚º Lv.${currentRing.tier}ï¼`);
                } else {
                    log(`ğŸ’ ${currentRing.name} å·²æ˜¯ Lv.4ï¼Œç›¸åŒæˆ’æŒ‡è‡ªå‹•åˆ†è§£ï¼ˆç›®å‰ä¸çµ¦é¡å¤–æ•ˆæœï¼‰ã€‚`);
                }
                updateStatus();
                return;
            }
            newLoot = loot;
            enterRingDecision();
            return;
        }

            if (lootType === 'WEAPON') {
                const currentW = hero.equipment.WEAPON;
        
                // 1. æ²’æ­¦å™¨ / å¾’æ‰‹ â†’ ç›´æ¥è£ä¸Š
                if (!currentW || currentW.name === "å¾’æ‰‹") {
                    hero.equipment.WEAPON = loot;
                    log(`ğŸ‘ è£å‚™äº†æ–°çš„ <span class="${RARITY_COLORS[loot.rarity]}">${loot.name}</span>ï¼`);
                    updateStatus();
                    return;
                }
        
                // 2. åˆ¤æ–·æ–°æ­¦å™¨æœ‰æ²’æœ‰æ¯”è¼ƒå¥½
                const lootRIndex = RARITY_ORDER.indexOf(loot.rarity);
                const curRIndex  = RARITY_ORDER.indexOf(currentW.rarity);
        
                let isBetter = false;
                if (lootRIndex > curRIndex) isBetter = true;
                else if (lootRIndex === curRIndex && loot.power > currentW.power) isBetter = true;
        
                if (isBetter) {
                    // 2-1. å…ˆæŠŠèˆŠæ­¦å™¨çš„è³‡æ–™å…¨éƒ¨å­˜èµ·ä¾†ï¼ˆè¦æ²¿ç”¨çš„æ±è¥¿ï¼‰
                    const oldAffix         = currentW.affixes ? [...currentW.affixes] : [];
                    const oldRefineLevel   = hero.weaponRefineLevel || 0;
                    const oldRefineAffixes = hero.weaponRefineAffixes ? [...hero.weaponRefineAffixes] : [];
        
                    // 2-2. èˆŠæ­¦å™¨æ‹†æˆç´ æ
                    const matOld = (RARITY_MATERIAL_VALUE[currentW.rarity] || 0);
                    if (matOld > 0 && currentW.name !== "å¾’æ‰‹") {
                        weaponMaterials += matOld;
                        log(`ğŸ”§ åŸæœ¬çš„ <span class="${RARITY_COLORS[currentW.rarity]}">${currentW.name}</span> è¢«åˆ†è§£ç‚ºæ­¦å™¨ç´ æ x${matOld}ã€‚ (æ­¦å™¨ç´ æ: ${weaponMaterials}/${WEAPON_MATERIAL_PER_REFINE})`);
                        while (weaponMaterials >= WEAPON_MATERIAL_PER_REFINE) {
                            weaponMaterials -= WEAPON_MATERIAL_PER_REFINE;
                            attemptWeaponRefine();
                        }
                    }
        
                    // 2-3. æ›ä¸Šæ–°æ­¦å™¨æœ¬é«”
                    hero.equipment.WEAPON = loot;
        
                    // 2-4. æ–°æ­¦å™¨è‡ªå¸¶è©æ¢ + èˆŠæ­¦å™¨è©æ¢ â†’ åˆä½µ
                    const newOwnAffix = loot.affixes || [];
                    hero.equipment.WEAPON.affixes = [...new Set([...newOwnAffix, ...oldAffix])];
        
                    // 2-5. ç²¾ç·´ç­‰ç´šèˆ‡ç²¾ç·´è©æ¢å®Œæ•´æ²¿ç”¨
                    hero.weaponRefineLevel   = oldRefineLevel;
                    hero.weaponRefineAffixes = [...oldRefineAffixes];
        
                    log(`â­ æ–°æ­¦å™¨æ›´å¼·ï¼å·²æ›´æ›ç‚º <span class="${RARITY_COLORS[loot.rity]}">${loot.name}</span>ï¼ˆä¿ç•™èˆŠæ­¦å™¨è©æ¢èˆ‡ç²¾ç·´æ•ˆæœï¼‰ï¼`);
                    updateStatus();
                } else {
                    // 3. æ–°æ­¦å™¨æ¯”è¼ƒçˆ› â†’ ç›´æ¥æ‹†æˆç´ æï¼ˆä¸å‹•åŸæœ¬æ­¦å™¨ï¼‰
                    let mat = RARITY_MATERIAL_VALUE[loot.rarity] || 0;
                    const sMatMod = hero.equipment.SHIELD.affixes && hero.equipment.SHIELD.affixes.includes('S_MAT_BOOST') ? 1 : 0;
                    if (sMatMod && mat > 0 && Math.random() < 0.3) {
                        mat += 1;
                        log("ğŸ› ã€ŒYA~æ’¿åˆ°åå¡ŠéŒ¢ã€ç™¼å‹•ï¼Œå¤šå‡ºä¸€é»ç´ æã€‚");
                    }
                    if (mat > 0) {
                        weaponMaterials += mat;
                        log(`ğŸ”§ <span class="${RARITY_COLORS[loot.rarity]}">${loot.name}</span> è¢«åˆ†è§£ç‚ºæ­¦å™¨ç´ æ x${mat}ã€‚ (æ­¦å™¨ç´ æ: ${weaponMaterials}/${WEAPON_MATERIAL_PER_REFINE})`);
                        while (weaponMaterials >= WEAPON_MATERIAL_PER_REFINE) {
                            weaponMaterials -= WEAPON_MATERIAL_PER_REFINE;
                            attemptWeaponRefine();
                        }
                    } else {
                        log(`ğŸ‘ ç°è‰²æ­¦å™¨å“è³ªå¤ªå·®ï¼Œè¢«ä¸Ÿæ£„ã€‚`);
                    }
                    updateStatus();
                }
                return;
            }


        const currentS = hero.equipment.SHIELD;
        if (!currentS || currentS.name === "ç„¡") {
            hero.equipment.SHIELD = loot;
            log(`ğŸ‘ è£å‚™äº†æ–°çš„ <span class="${RARITY_COLORS[loot.rarity]}">${loot.name}</span>ï¼`);
            updateStatus();
            return;
        }

        const lootRIndex = RARITY_ORDER.indexOf(loot.rarity);
        const curRIndex  = RARITY_ORDER.indexOf(currentS.rarity);
        let betterShield = false;
        if (lootRIndex > curRIndex) betterShield = true;
        else if (lootRIndex === curRIndex && loot.power > currentS.power) betterShield = true;

        if (betterShield) {
            hero.equipment.SHIELD = loot;
            log(`â­ æ–°ç›¾ç‰Œæ›´å¼·ï¼å·²æ›´æ›ç‚º <span class="${RARITY_COLORS[loot.rarity]}">${loot.name}</span>ï¼`);
            updateStatus();
        } else {
            let mat = RARITY_MATERIAL_VALUE[loot.rarity] || 0;
            const sMatMod = currentS.affixes && currentS.affixes.includes('S_MAT_BOOST') ? 1 : 0;
            if (sMatMod && mat > 0 && Math.random() < 0.3) {
                mat += 1;
                log("ğŸ› ã€ŒYA~æ’¿åˆ°åå¡ŠéŒ¢ã€ç™¼å‹•ï¼Œå¤šå‡ºä¸€é»ç›¾ç‰Œç´ æã€‚");
            }
            if (mat > 0) {
                shieldMaterials += mat;
                log(`ğŸ”© <span class="${RARITY_COLORS[loot.rarity]}">${loot.name}</span> è¢«åˆ†è§£ç‚ºç›¾ç‰Œç´ æ x${mat}ã€‚ (ç›¾ç‰Œç´ æ: ${shieldMaterials}/${SHIELD_MATERIAL_PER_REFINE})`);
                while (shieldMaterials >= SHIELD_MATERIAL_PER_REFINE) {
                    shieldMaterials -= SHIELD_MATERIAL_PER_REFINE;
                    attemptShieldRefine();
                }
            } else {
                log(`ğŸ‘ ç°è‰²ç›¾ç‰Œå“è³ªå¤ªå·®ï¼Œè¢«ä¸Ÿæ£„ã€‚`);
            }
            updateStatus();
        }
    }

    function enterRingDecision() {
        gameState = 'LOOT_RING_DECISION';
        commandMenu.style.display = 'none';
        decisionMenu.style.display = 'flex';

        const currentRing = hero.equipment.RING;
        const newRing = newLoot;

        const currentRingColor = RARITY_COLORS[currentRing.rarity];
        const newRingColor = RARITY_COLORS[newRing.rarity];

        const currentRingNameHtml = `<span class="${currentRingColor}">${currentRing.name}</span>`;
        const newRingNameHtml = `<span class="${newRingColor}">${newRing.name}</span>`;

        let decisionText = `ğŸ’ æ›ä¸Š Lv.${newRing.tier} çš„ ${newRing.name}`;

        mainView.style.backgroundColor = '#2c3e50';
        mainView.innerHTML = `
<p style="color:#ffcc00;">ğŸ”” ç™¼ç¾æ–°æˆ’æŒ‡! è«‹æ‰‹å‹•é¸æ“‡æ˜¯å¦æ›¿æ›æˆ–å‡ç´š</p>
<p style="text-align: left; padding: 0 20px;">
ã€ç¾æœ‰æˆ’æŒ‡ã€‘ï¼š${currentRingNameHtml} (${currentRing.ability.desc}, Lv.${currentRing.tier})<br>
ã€æ–°æˆ’æŒ‡ã€‘ï¼š${newRingNameHtml} (${newRing.ability.desc}, Lv.${newRing.tier})
</p>
        `;
        btnDecYes.textContent = decisionText;
        btnDecNo.textContent = `â­• ä¿ç•™ Lv.${currentRing.tier} çš„ ${currentRing.name} (ä¸Ÿæ£„æ–°)`;
    }

    function handleRingDecision(choice) {
        if (gameState !== 'LOOT_RING_DECISION') return;
        const currentRing = hero.equipment.RING;
        const newRing = newLoot;

        if (choice === 'YES') {
            hero.equipment.RING = newRing;
            log(`ğŸ’ æ‰‹å‹•ç¢ºèª: æˆåŠŸæ›ä¸Šäº† Lv.${newRing.tier} çš„ <span class="${RARITY_COLORS[newRing.rarity]}">${newRing.name}</span>!`);
        } else {
            log(`ğŸ—‘ï¸ æ‰‹å‹•ç¢ºèª: æ”¾æ£„äº† <span class="${RARITY_COLORS[newRing.rarity]}">${newRing.name}</span>ã€‚`);
        }
        newLoot = null;
        updateStatus();
        decisionMenu.style.display = 'none';
        setTimeout(enterMap, 500);
    }

    function disableCommands(disabled) {
        commandMenu.querySelectorAll('.command-btn').forEach(btn => btn.disabled = disabled);
        if (disabled) decisionMenu.style.display = 'none';
    }

    // åˆå§‹åŒ–æˆ’æŒ‡ç‚º NONE
    hero.equipment.RING = {
        name: "ç„¡",
        ability: RING_ABILITIES.find(a => a.id === 'NONE'),
        tier: 0,
        rarity: 'Normal'
    };
    
    function startGame() {
    
        // â˜… å¦‚æœ hero.title å·²ç¶“è¨­å®šï¼Œé€™è£¡ç«‹å³æ›´æ–°ç•«é¢ï¼ˆæœ€é‡è¦ï¼‰
        updateStatus();
    
        calculateHeroStats();
        updateStatus(); // ç¬¬äºŒæ¬¡ä¿éšª
        enterMap();
    }


    // ===== é é¢è¼‰å…¥å¾Œï¼šå…ˆè™•ç†ç¨±è™Ÿï¼Œå†å•Ÿå‹•éŠæˆ² =====
    // ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼
    // ç§°è™Ÿé¸å–®é‚è¼¯ï¼ˆä½ å·²ç¶“å¯«å¥½çš„å€åŸŸï¼‰
    // ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼
    
    window.addEventListener('load', () => {
        initTitleSelectBox();
    
        document.getElementById("titleSelectBox").style.display = "flex";
    });
    
    const btnConfirmTitle = document.getElementById("btnConfirmTitle");
    
    btnConfirmTitle.addEventListener("click", () => {
        const selectedA = document.getElementById("sel-A").value;
        const selectedB = document.getElementById("sel-B").value;
        const selectedC = document.getElementById("sel-C").value;
    
        const selectedTitle = `${selectedA}çš„${selectedB}${selectedC}`;
        hero.title = selectedTitle;
    
        updateStatus();
        document.getElementById("titleSelectBox").style.display = "none";
    
        startGame();
    });
    
    
    // â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…
    // â˜… åœ¨é€™è£¡åŠ å…¥å›åˆæ•¸æŒ‰éˆ•ç›£è½ï¼ˆæ­£ç¢ºä½ç½®ï¼‰â˜…
    // â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…
    
    // å‡ºç™¼å†’éšªæŒ‰éˆ•
    btnAdventure.addEventListener('click', () => {
        spendTurn();          // â† å…ˆåŠ å›åˆ
        startSmallBattle();   // å†é€²å…¥å°æˆ°é¬¥
    });
    
    // æŒ‘æˆ° Boss
    btnBoss1.addEventListener('click', () => {
        spendTurn();
        startBossBattle(1);
    });
    
    // ä¼‘æ¯
    btnRest.addEventListener('click', () => {
        spendTurn();
        restHero();
    });


</script>

</body>
</html>


















