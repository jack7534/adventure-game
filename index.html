<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ—ºï¸ å‹‡è€…æ¨¡æ“¬å™¨ï¼šç¨€æœ‰åº¦åˆ†ç´šç‰ˆ</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px 0;
            background-color: #e8f5e9;
        }
        #game-container {
            width: 90%;
            max-width: 650px;
            padding: 20px;
            background-color: #fff;
            border: 5px solid #000;
            box-shadow: 6px 6px 0px #4caf50;
            text-align: center;
            margin-bottom: 20px;
        }
        #status-box {
            background-color: #f0f4c3;
            border: 2px solid #000;
            padding: 10px;
            margin-bottom: 15px;
            text-align: left;
            font-size: 14px;
        }
        #equipment-status {
            margin-top: 4px;
        }
        #extra-status {
            margin-top: 4px;
        }
        #main-view {
            height: 180px;
            border: 3px solid #000;
            background-color: #1a2a3a;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            white-space: pre;
            line-height: 1.1;
            font-size: 18px;
            margin-bottom: 15px;
            transition: background-color 0.1s;
        }

        .transition-flash-on { background-color: #000000 !important; transition: none; }
        .transition-flash-off { background-color: #ffffff !important; transition: none; }

        .hero-hit-flash { background-color: #ffd700 !important; }
        .monster-hit-flash { background-color: #ff3333 !important; }
        .crit-flash { background-color: #ffaa00 !important; }
        .heal-flash { background-color: #33ff33 !important; }

        .loot-Magic { background-color: #003300 !important; color: #00aa00; font-size: 24px;}
        .loot-Rare { background-color: #000033 !important; color: #00aaff; font-size: 28px;}
        .loot-Epic { background-color: #330033 !important; color: #aa00aa; font-size: 30px;}
        .loot-Legendary { background-color: #331a00 !important; color: #FF8C00; font-size: 32px;}
        .loot-Mythic { background-color: #330000 !important; color: #FF0000; font-size: 34px;}
        .loot-Normal { background-color: #333333 !important; color: #ffffff; font-size: 20px;}

        #command-menu {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-bottom: 15px;
        }
        .command-btn {
            padding: 10px 15px;
            font-size: 16px;
            cursor: pointer;
            border: 2px solid #000;
            background-color: #ffcc00;
            box-shadow: 2px 2px 0px #000;
            flex-grow: 1;
            min-width: 100px;
            transition: background-color 0.2s;
        }
        .command-btn:hover:not(:disabled) { background-color: #ffd740; }
        .command-btn:disabled { background-color: #ccc; cursor: not-allowed; }

        .defend-btn {
            background-color: #2196F3;
            color: white;
            font-weight: bold;
        }

        #decision-menu {
            display: none;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
            padding: 10px 0;
            border-top: 2px solid #ccc;
        }
        .decision-btn {
            padding: 10px 15px;
            font-size: 16px;
            cursor: pointer;
            border: 2px solid #000;
            background-color: #f44336;
            color: white;
            box-shadow: 2px 2px 0px #000;
            flex-grow: 1;
            min-width: 150px;
        }
        .decision-btn-yes { background-color: #4CAF50; }
        .decision-btn-no { background-color: #F44336; }

        #message-log {
            min-height: 120px;
            border: 2px solid #000;
            padding: 10px;
            text-align: left;
            overflow-y: auto;
            max-height: 120px;
            background-color: #fcfcfc;
            font-size: 13px;
        }
        .log-msg { margin: 2px 0; }

        #equipment-display {
            margin-top: 15px;
            border: 2px solid #000;
            padding: 10px;
            text-align: left;
            background-color: #fcfcfc;
            font-size: 14px;
            line-height: 1.6;
        }

        .Rarity-Normal { color: #808080; }
        .Rarity-Magic { color: #00AA00; font-weight: bold; }
        .Rarity-Rare { color: #0000AA; font-weight: bold; }
        .Rarity-Epic { color: #AA00AA; font-weight: bold; }
        .Rarity-Legendary { color: #FF8C00; font-weight: bold; }
        .Rarity-Mythic { color: #FF0000; font-weight: bold; }

        #game-manual {
            width: 90%;
            max-width: 650px;
            padding: 20px;
            margin-top: 20px;
            background-color: #f9f9f9;
            border: 2px dashed #4caf50;
            text-align: left;
            font-size: 13px;
            line-height: 1.8;
        }
        #game-manual h3 {
            color: #2e7d32;
            border-bottom: 1px solid #4caf50;
            padding-bottom: 5px;
            margin-top: 15px;
        }
    </style>
</head>
<body>

<div id="game-container">
    <h1>ğŸ—ºï¸ å‹‡è€…æ¨¡æ“¬å™¨ï¼šæ‰“å¯¶èˆ‡é¤Šæˆ</h1>

    <div id="status-box">
        å‹‡è€…: Lv.<span id="hero-level">1</span>
        (EXP: <span id="hero-exp">0</span>/<span id="hero-exp-max">10</span>)<br>
        HP: <span id="hero-hp">20</span> / <span id="hero-max-hp">20</span><br>
        <div id="equipment-status">
            ATK: <span id="hero-atk-val">15</span> |
            DEF: <span id="hero-def-val">10</span> |
            MATK: <span id="hero-matk-val">20</span>
        </div>
        <div id="extra-status">
            é–ƒé¿: <span id="hero-dodge-val">15</span>% |
            å¹³æ‰‹å‹ç‡: <span id="hero-tie-win-rate-val">30</span>% |
            çˆ†æ“Š: <span id="hero-crit-val">5</span>%
        </div>
    </div>

    <div id="main-view">
        <p>æ­¡è¿ä¾†åˆ°å†’éšªä¸–ç•Œï¼</p>
    </div>

    <div id="command-menu">
        <button id="btn-action-1" class="command-btn" onclick="handleMapAction('Small')">æ¢ç´¢ (æ‰¾å°æ€ª)</button>
        <button id="btn-action-2" class="command-btn" onclick="handleMapAction('Boss')">æŒ‘æˆ° Boss å¯¶è—</button>
        <button id="btn-action-3" class="command-btn" onclick="handleMapAction('Heal')">ä¼‘æ¯ (æ¢å¾© HP)</button>
    </div>

    <div id="decision-menu">
        <button id="btn-decision-yes" class="decision-btn decision-btn-yes" onclick="handleRingDecision('YES')">ğŸ’ æ›ä¸Š/å‡ç´šæ–°æˆ’æŒ‡</button>
        <button id="btn-decision-no" class="decision-btn decision-btn-no" onclick="handleRingDecision('NO')">ğŸš« ä¿ç•™èˆŠæˆ’æŒ‡</button>
    </div>

    <div id="message-log">
        <div class="log-msg">å‹‡è€…è¸ä¸Šäº†å†’éšªçš„æ—…é€”...</div>
    </div>

    <div id="equipment-display">
        **âš™ï¸ è£å‚™æ¬„**<br>
        æ­¦: <span id="eq-weapon">å¾’æ‰‹</span> |
        ç›¾: <span id="eq-shield">ç„¡</span> |
        æˆ’: <span id="eq-ring">ç„¡</span><br>
        ç²¾ç·´ç­‰ç´šï¼šæ­¦å™¨ç²¾ç·´ +<span id="weapon-refine-level">0</span> (ç´ æ <span id="weapon-materials">0</span>/5)ï¼›
        ç›¾ç‰Œç²¾ç·´ +<span id="shield-refine-level">0</span> (ç´ æ <span id="shield-materials">0</span>/5)
        <hr style="border-top: 1px solid #ccc; margin: 5px 0;">
        **ğŸ›¡ï¸ è£å‚™å±¬æ€§**<br>
        æ”»: <span id="eq-detail-weapon">æ”»æ“ŠåŠ› +0</span> |
        é˜²: <span id="eq-detail-shield">é˜²ç¦¦åŠ› +0</span><br>
        æˆ’: <span id="eq-detail-ring">ç‰¹æ•ˆï¼šç„¡ (Lv.0)</span><br>
        æ­¦å™¨è©æ¢: <span id="eq-weapon-affix">ç„¡</span><br>
        ç›¾ç‰Œè©æ¢: <span id="eq-shield-affix">ç„¡</span>
    </div>
</div>

<div id="game-manual">
    <h2>ğŸ“– éŠæˆ²èªªæ˜èˆ‡æˆ°é¬¥è¦å‰‡</h2>

    <h3>âš”ï¸ æˆ°é¬¥ç³»çµ±ï¼šä¸‰ç¨®æ‹›å¼ + å…‹åˆ¶é—œä¿‚</h3>
    <ul>
        <li>æ‹›å¼ï¼š
            <ul>
                <li>âš”ï¸ <b>ç æ“Šï¼ˆç‰©ç†ï¼‰</b>ï¼šåƒ ATKï¼Œå‚·å®³ = ATK âˆ’ æ€ªç‰© DEFï¼Œæœƒè¢«æ€ªç‰©é–ƒé¿å½±éŸ¿ã€‚</li>
                <li>ğŸª„ <b>é­”æ³•æ”»æ“Š</b>ï¼šåƒ MATKï¼Œå‚·å®³ = é­”æ”» âˆ’ æ€ªç‰© MDEFï¼Œ<b>çµ•å°å‘½ä¸­ï¼Œä¸æœƒè¢«é–ƒé¿</b>ã€‚</li>
                <li>ğŸ›¡ï¸ <b>ç›¾æ“Š</b>ï¼šå‚·å®³ = ä½ ç›®å‰çš„ <b>DEF æ•¸å€¼</b>ï¼Œ<b>å®Œå…¨ç„¡è¦–æ€ªç‰©æ‰€æœ‰é˜²ç¦¦ (DEF/MDEF)</b>ï¼Œä½†æœƒè¢«æ€ªç‰©é–ƒé¿ã€‚</li>
            </ul>
        </li>
        <li><b>å…‹åˆ¶é—œä¿‚ï¼š</b> âš”ï¸ > é­”æ³• > ç›¾æ“Š > âš”ï¸ï¼ˆå¯¦éš›æŒ‰éˆ•ä¾åœ–ç¤ºé¡¯ç¤ºï¼‰ã€‚</li>
        <li><b>å…‹åˆ¶ï¼š</b> å‹æ–¹é€ æˆå‚·å®³ï¼Œè¢«å…‹åˆ¶æ–¹è©²å›åˆå®Œå…¨å¤±æ•ˆã€‚</li>
        <li><b>å¹³æ‰‹ï¼š</b> å‡ºåŒä¸€æ‹›ï¼Œä¾ã€Œå¹³æ‰‹å‹ç‡ã€åˆ¤å®šæ˜¯æˆ‘æ–¹æ‰“é‚„æ˜¯æ€ªæ‰“ã€‚</li>
        <li><b>ç›¾æ“Šå‚·å®³ï¼š</b> ä¸çœ‹ä»»ä½•é˜²ç¦¦ï¼Œç›´æ¥åƒ DEFï¼Œé˜²ç¦¦å †è¶Šé«˜ï¼Œç›¾æ“Šè¶Šç—›ã€‚</li>
    </ul>

    <h3>ğŸ˜ˆ æ€ªç‰©èˆ‡å¼±é»</h3>
    <ul>
        <li><b>å“¥å¸ƒæ—ï¼š</b> å‡è¡¡å‹ï¼Œå°å° dodgeï¼Œç‰©é˜²/é­”é˜²æ™®é€šã€‚</li>
        <li><b>éª·é«å…µï¼š</b> ç‰©é˜²é«˜ã€é­”é˜²ä½ â†’ æ¨è–¦é­”æ³•æ”»æ“Šã€‚</li>
        <li><b>é‡ç‹¼ï¼š</b> é­”é˜²é«˜ã€ç‰©é˜²ä½ï¼Œè‡ªå·± dodge ä¹Ÿåé«˜ â†’ æ¨è–¦ç æ“Šã€‚</li>
        <li><b>çŸ³é ­äººï¼š</b> è¶…é«˜ç‰©é˜²ã€é­”é˜²å¾ˆä½ï¼Œé˜²ç¦¦ä¹Ÿå¾ˆåšï¼Œæœ€æ€• <b>ç›¾æ“Š</b>ï¼ˆç”¨ DEF æ‰“ç©¿ä¸€åˆ‡ï¼‰ã€‚</li>
        <li><b>è™è ï¼š</b> é­”é˜²é«˜åˆå¾ˆæœƒé–ƒ â†’ é­”æ³•æ”»æ“Šå¿…ä¸­æœ€ç©©ã€‚</li>
    </ul>

    <h3>ğŸ“Š èƒ½åŠ›å€¼èªªæ˜</h3>
    <ul>
        <li><b>ATKï¼š</b> å½±éŸ¿ âš”ï¸ ç æ“Šçš„ç‰©ç†å‚·å®³ã€‚</li>
        <li><b>DEFï¼š</b> æ¸›å°‘æ€ªç‰©ç‰©ç†å‚·å®³ï¼Œä¸¦æ±ºå®šï¼š
            <ul>
                <li>ğŸ›¡ï¸ ç›¾æ“Šå‚·å®³ = DEFï¼ˆç„¡è¦–é˜²ç¦¦ï¼‰ã€‚</li>
            </ul>
        </li>
        <li><b>MATKï¼š</b> é­”æ”»ï¼Œç”¨ä¾†è¨ˆç®—é­”æ³•æ”»æ“Šå‚·å®³èˆ‡éƒ¨ä»½å›å¾©é‡ã€‚</li>
        <li><b>é–ƒé¿ï¼š</b> æœ‰æ©Ÿç‡å®Œå…¨é–ƒæ‰æ•µæ–¹æ”»æ“Šï¼ˆæ•æ·æˆ’æŒ‡ã€ç›¾ç‰Œè©æ¢å¯æå‡ï¼‰ã€‚</li>
        <li><b>å¹³æ‰‹å‹ç‡ï¼š</b> é›™æ–¹å‡ºåŒæ‹›æ™‚ï¼Œæˆ‘æ–¹è¢«åˆ¤å®šç‚ºã€Œè´ã€çš„æ©Ÿç‡ã€‚</li>
        <li><b>çˆ†æ“Šï¼š</b> æœ‰å¹¸é‹æˆ’æŒ‡æ™‚å¤§å¹…æé«˜ï¼›ç æ“Š / ç›¾æ“Šéƒ½æœ‰æ©Ÿæœƒçˆ†æ“Šï¼Œé€ æˆé›™å€å‚·å®³ã€‚</li>
    </ul>

    <h3>ğŸ’ æˆ’æŒ‡èƒ½åŠ›è©³ç´°èªªæ˜</h3>
    <ul>
        <li><b>å¹¸é‹æˆ’æŒ‡ (CRIT)</b>
            <ul>
                <li>æ•ˆæœï¼šæé«˜æš´æ“Šæ©Ÿç‡ï¼Œä¸¦ç•¥å¾®æå‡é­”æ³•ç›¸é—œå‚·å®³ã€‚</li>
                <li>çˆ†æ“Šç‡ï¼šç´„ 20% (Lv1) â†’ 50% (Lv4)ã€‚</li>
                <li>çˆ†æ“Šç™¼ç”Ÿæ™‚ï¼Œç æ“Š/ç›¾æ“Šå‚·å®³ Ã—2ã€‚</li>
            </ul>
        </li>
        <li><b>ç”Ÿå‘½æˆ’æŒ‡ (HEAL)</b>
            <ul>
                <li>æ•ˆæœï¼šé˜²ç¦¦æˆåŠŸæ™‚å›å¾© HPï¼Œä¸¦æå‡ DEFã€‚</li>
                <li>é˜²ç¦¦æˆåŠŸå›å¾©ï¼šç´„ 8~24 HPï¼ˆéš¨ç­‰ç´šä¸Šå‡ï¼‰ã€‚</li>
            </ul>
        </li>
        <li><b>æ•æ·æŒ‡ç’° (DODGE)</b>
            <ul>
                <li>æ•ˆæœï¼šå¤§å¹…æå‡é–ƒé¿ç‡ã€‚</li>
                <li>é–ƒé¿ç‡é¡å¤–æå‡ç´„ 10%~40%ï¼ˆè¦–ç­‰ç´šï¼‰ï¼›æœ€é«˜ä¸è¶…é 80%ã€‚</li>
            </ul>
        </li>
        <li><b>é­”å°æŒ‡ç’° (MAGIC)</b>
            <ul>
                <li>æ•ˆæœï¼šå¤§å¹…æå‡é­”æ³•æ”»æ“Šå‚·å®³ã€‚</li>
            </ul>
        </li>
        <li><b>ç‹‚æˆ°å£«æŒ‡ç’° (BERSERKER)</b>
            <ul>
                <li>æ•ˆæœï¼šçŠ§ç‰²æœ€å¤§ HP æ›å–å¤§é‡ ATKï¼Œç‰©ç†æ”»æ“Šæœ‰æ©Ÿæœƒå¤šæ®µæ”»æ“Šã€‚</li>
            </ul>
        </li>
        <li><b>å¹³è¡¡æŒ‡ç’° (BALANCE)</b>
            <ul>
                <li>æ•ˆæœï¼šæé«˜å¹³æ‰‹æ™‚ç”±å‹‡è€…ç²å‹çš„æ©Ÿç‡ã€‚</li>
            </ul>
        </li>
    </ul>

    <h3>ğŸ’ è£å‚™ç¨€æœ‰åº¦èˆ‡æ‰è½è§£é–</h3>
    <ul>
        <li><span class="Rarity-Normal">ç°è‰² Normal</span></li>
        <li><span class="Rarity-Magic">ç¶ è‰² Magic</span></li>
        <li><span class="Rarity-Rare">è—è‰² Rare</span></li>
        <li><span class="Rarity-Epic">ç´«è‰² Epic</span></li>
        <li><span class="Rarity-Legendary">æ©˜è‰² Legendary</span></li>
        <li><span class="Rarity-Mythic">ç´…è‰² Mythic</span></li>
    </ul>
    <p>æ‰è½éšæ®µï¼ˆæ­¦å™¨ / ç›¾ç‰Œï¼‰ï¼š</p>
    <ul>
        <li><b>æ‰“ç¬¬ä¸€éš» Boss ä¹‹å‰ï¼š</b> åªæœƒæ‰ ç´« / è— / ç¶  / ç°ï¼Œ<b>ä¸æœƒå‡ºæ©˜æ­¦ã€æ©˜ç›¾ã€ç´…æ­¦ã€ç´…ç›¾</b>ã€‚</li>
        <li><b>æ‰“æ­»ç¬¬ä¸€éš» Boss ä¹‹å¾Œï¼š</b> é–‹å§‹åŠ å…¥ <span class="Rarity-Legendary">æ©˜æ­¦ã€æ©˜ç›¾</span> çš„æ¬Šé‡ã€‚</li>
        <li><b>æ‰“æ­»ç¬¬äºŒéš» Boss ä¹‹å¾Œï¼š</b> å†åŠ å…¥ <span class="Rarity-Mythic">ç´…æ­¦ã€ç´…ç›¾</span> çš„æ¬Šé‡ã€‚</li>
        <li>æˆ’æŒ‡æ‰è½é¡è‰²æœ€å¤šä¸Šçœ‹åˆ°æ©˜è‰²ï¼éƒ¨åˆ†è¨­è¨ˆï¼Œé¿å…ä¸€é–‹å§‹å°±ç´…æˆ’æŒ‡å¤ªå¤±è¡¡ã€‚</li>
    </ul>

    <h3>ğŸ§² æ­¦å™¨ / ç›¾ç‰Œè©æ¢èªªæ˜</h3>
    <p><b>æ­¦å™¨è©æ¢ï¼ˆæœƒå¥—ç”¨åœ¨ç æ“Šã€ç›¾æ“Šç­‰ç‰©ç†è¡Œç‚ºï¼‰</b></p>
    <ul>
        <li><b>è¿½åŠ æ”»æ“Š (W_EXTRA_HIT)ï¼š</b> ç‰©ç†æ”»æ“Šæ™‚æœ‰ 20% æ©Ÿç‡å†è¿½åŠ ä¸€æ¬¡ç›¸åŒå‚·å®³ã€‚</li>
        <li><b>éŠ³åˆ©ä¹‹åˆƒ (W_ATK_UP)ï¼š</b> å¢åŠ å°‘é‡ ATKã€‚</li>
        <li><b>é­”åŠ›å°ç®¡ (W_MAGIC_UP)ï¼š</b> å¢åŠ å°‘é‡ MATKã€‚</li>
        <li><b>ç ´ç”² (W_ARMOR_PEN)ï¼š</b> ç æ“Šæ™‚ç•¥å¾®ç„¡è¦–æ•µæ–¹é˜²ç¦¦ã€‚</li>
        <li><b>å¸è¡€ (W_LIFESTEAL)ï¼š</b> é€ æˆå‚·å®³çš„ä¸€éƒ¨åˆ†æœƒå›å¾©è‡ªèº« HPã€‚</li>
        <li><b>æˆ°é¬¥æœ¬èƒ½ (W_BALANCE)ï¼š</b> å¹³æ‰‹æ™‚ç¨å¾®æé«˜æˆ‘æ–¹åˆ¤å®šå‹ç‡ã€‚</li>
    </ul>
    <p><b>ç›¾ç‰Œè©æ¢ï¼ˆé˜²ç¦¦ç›¸é—œï¼‰</b></p>
    <ul>
        <li><b>æ ¼æ“‹ (S_BLOCK)ï¼š</b> å—åˆ°å‚·å®³æ™‚æœ‰ 20% æ©Ÿç‡å†æ¸›åŠã€‚</li>
        <li><b>é­”åŠ›è­·ç½© (S_MAGIC_GUARD)ï¼š</b> ä½¿ç”¨é­”æ³•æ”»æ“Š / ç›¾æ“Šæ™‚æœ‰ 20% æ©Ÿç‡å•Ÿå‹• 3 å›åˆ 50% æ¸›å‚·ã€‚</li>
        <li><b>åšé‡è­·ç”² (S_DEF_UP)ï¼š</b> æå‡å°‘é‡ DEFã€‚</li>
        <li><b>å†·éœåˆ¤æ–· (S_TIE_UP)ï¼š</b> æå‡å°‘é‡å¹³æ‰‹å‹ç‡ã€‚</li>
        <li><b>èŠæ£˜è­·ç›¾ (S_REFLECT)ï¼š</b> å—åˆ°å‚·å®³æ™‚å°‡ä¸€éƒ¨ä»½åå°„çµ¦æ•µäººã€‚</li>
        <li><b>éˆå·§é˜²ç¦¦ (S_DODGE_UP)ï¼š</b> æå‡å°‘é‡é–ƒé¿ç‡ã€‚</li>
    </ul>

    <h3>ğŸ›  æ­¦å™¨ç²¾ç·´ï¼ˆç¨ç«‹ç³»çµ±ï¼‰èˆ‡ç›¾ç‰Œç²¾ç·´</h3>
    <ul>
        <li><b>æ­¦å™¨ç²¾ç·´æ˜¯ç¨ç«‹ç³»çµ±ï¼Œä¸ç¶åœ¨å–®ä¸€æ­¦å™¨ä¸Šï¼š</b>
            <ul>
                <li>è§’è‰²æœ‰ä¸€å€‹ã€Œæ­¦å™¨ç²¾ç·´ç­‰ç´šã€èˆ‡ã€Œæ­¦å™¨ç²¾ç·´è©æ¢ã€ã€‚</li>
                <li>æ›æˆæ–°çš„æ­¦å™¨æ™‚ï¼Œç²¾ç·´ç­‰ç´šèˆ‡ç²¾ç·´è©æ¢æœƒ<b>å®Œæ•´ä¿ç•™</b>ï¼Œè‡ªå‹•å¥—ç”¨åœ¨æ–°æ­¦å™¨ä¸Šã€‚</li>
            </ul>
        </li>
        <li><b>ç›¾ç‰Œç²¾ç·´ï¼š</b> ç¶åœ¨è©²é¢ç›¾ç‰Œä¸Šï¼Œæ›ç›¾æœƒæ›æ‰ã€‚</li>
        <li><b>åˆ†è§£ï¼š</b>
            <ul>
                <li>ç°è£ä¸èƒ½åˆ†è§£ï¼Œå…¶å®ƒè£å‚™åˆ†è§£æˆç´ æï¼šç¶  1 / è— 2 / ç´« 3 / æ©˜ 4 / ç´… 5ã€‚</li>
                <li>æ›æ–°æ­¦å™¨æ™‚ï¼ŒèˆŠæ­¦æœƒè¢«è‡ªå‹•åˆ†è§£æˆç´ æã€‚</li>
            </ul>
        </li>
        <li><b>ç´ æä½¿ç”¨ï¼š</b>
            <ul>
                <li>æ­¦å™¨ç´ æï¼šæ¯ç´¯ç© 5 é» â†’ é€²è¡Œä¸€æ¬¡æ­¦å™¨ç²¾ç·´ã€‚</li>
                <li>ç›¾ç‰Œç´ æï¼šæ¯ç´¯ç© 5 é» â†’ é€²è¡Œä¸€æ¬¡ç›¾ç‰Œç²¾ç·´ï¼ˆç¶åœ¨ç›®å‰è£å‚™çš„ç›¾ï¼‰ã€‚</li>
            </ul>
        </li>
    </ul>

    <h3>ğŸ”„ ç­‰ç´šã€æ­»äº¡æ‡²ç½°èˆ‡æœ€é«˜ç­‰ç´€éŒ„</h3>
    <ul>
        <li>å‡ç´šï¼š
            <ul>
                <li>æ¯å‡ 1 ç´šå›ºå®šå¢åŠ  HPï¼Œä¸¦éš¨æ©Ÿæå‡ ATK / DEF / é–ƒé¿ / å¹³æ‰‹ç‡ / MATKã€‚</li>
                <li>è§’è‰²æœƒè¨˜éŒ„ã€Œæ›¾åˆ°é”çš„æœ€é«˜ç­‰ç´šã€ï¼Œåªæœ‰è¶…éé€™å€‹ç­‰ç´šæ™‚æ‰æœƒå†ç²å¾—æ–°çš„èƒ½åŠ›æˆé•·ã€‚</li>
            </ul>
        </li>
        <li>æ­»äº¡æ‡²ç½°ï¼š
            <ul>
                <li>æœƒæ‰£æ‰ç•¶å‰ç­‰ç´šæ‰€éœ€ EXP çš„ä¸€éƒ¨åˆ†ï¼Œåš´é‡æ™‚é™ç´šã€‚</li>
                <li>é™ç´šæ™‚ï¼š<b>åªæœƒæ‰£æœ€å¤§ HP</b>ï¼Œä¹‹å‰ç´¯ç©çš„ ATK / DEF / é–ƒé¿ / å¹³æ‰‹ç‡ / MATK æˆé•·<b>ä¸æœƒè¢«æ‰£å›</b>ã€‚</li>
            </ul>
        </li>
        <li>ç·´å›åŸæœ¬ç­‰ç´šï¼š
            <ul>
                <li>å‡å›èˆŠçš„æœ€é«˜ç­‰ç´šæ™‚ï¼Œåªæœƒè£œå›å› é™ç´šå¤±å»çš„ HPï¼Œä¸æœƒå†å¤šä¸€æ¬¡èƒ½åŠ›æˆé•·ã€‚</li>
            </ul>
        </li>
        <li>Boss æœ€ä½é›£åº¦ï¼š
            <ul>
                <li>æ¯éš» Boss æœ‰è‡ªå·±çš„åŸºæº–ç­‰ç´šï¼ˆä¾‹å¦‚ Boss1=1, Boss2=2, Boss3=3ï¼‰ã€‚</li>
                <li>Boss çš„å¯¦éš›å¼·åº¦ä½¿ç”¨ <code>max(ä½ çš„ç­‰ç´š, BossåŸºæº–ç­‰ç´šÃ—5)</code> å»è¨ˆç®—ã€‚</li>
            </ul>
        </li>
    </ul>
</div>

<script>
    let gameState = 'MAP';
    const HERO_MAX_HP_START = 20;
    const MAX_LEVEL = 25;
    const HP_PER_LEVEL = 5;

    const RARITY_ORDER = ['Normal', 'Magic', 'Rare', 'Epic', 'Legendary', 'Mythic'];
    const RARITY_MATERIAL_VALUE = {
        Normal: 0, Magic: 1, Rare: 2, Epic: 3, Legendary: 4, Mythic: 5
    };

    // æ­¦å™¨ç²¾ç·´ï¼šç¶è§’è‰²
    const MAGIC_REFINE_BONUS = {
        Normal: 1, Magic: 3, Rare: 5, Epic: 8, Legendary: 12, Mythic: 16
    };
    const WEAPON_MATERIAL_PER_REFINE = 5;
    const SHIELD_MATERIAL_PER_REFINE = 5;
    let weaponMaterials = 0;
    let shieldMaterials = 0;

    // é­”å° / å¹¸é‹æˆ’æŒ‡å°é­”æ”»å€ç‡
    const MAGIC_RING_MAGIC_RATE = [0, 0.25, 0.50, 0.75, 1.00];
    const CRIT_RING_MAGIC_RATE  = [0, 0.10, 0.20, 0.30, 0.40];

    const BERSERKER_MULTI_HIT_CHANCE = [0, 0.15, 0.25, 0.35, 0.45];
    const BERSERKER_THIRD_HIT_CHANCE = [0, 0.0, 0.10, 0.20, 0.25];

    let hero = {
        name: 'ç„¡åè‹±é›„',
        hp: HERO_MAX_HP_START,
        maxHp: HERO_MAX_HP_START,
        level: 1,
        highestLevel: 1,
        exp: 0,
        expToNextLevel: 10,
        baseAttack: 15,
        baseDefense: 10,
        baseDodge: 15,
        baseTieWinRate: 30,
        baseMagicAtk: 20,
        equipment: {
            WEAPON: { name: "å¾’æ‰‹", power: 0, rarity: 'Normal', affixes: [] },
            SHIELD: { name: "ç„¡", power: 0, rarity: 'Normal', refine: 0, affixes: [], refineSlots: 0 },
            RING: { name: "ç„¡", ability: null, tier: 0, rarity: 'Normal' }
        },
        // ç‹‚æˆ°æˆ’æŒ‡ç”¨
        berserkerBonus: 0,
        berserkerPenalty: 0,
        healRingDefBonus: 0,
        // å³æ™‚è¨ˆç®—å€¼
        currentAttack: 0,
        currentDefense: 0,
        currentDodge: 0,
        currentTieWinRate: 0,
        currentMagicAtk: 0,
        magicGuardTurns: 0,
        // æ­¦å™¨ç²¾ç·´ç³»çµ±
        weaponRefineLevel: 0,
        weaponRefineSlots: 0,
        weaponRefineAffixes: []
    };

    function getShieldRefineLevel() {
        return hero.equipment.SHIELD.refine || 0;
    }

    let currentEnemy = null;
    let bossLevel = 1;
    let newLoot = null;

    let healCooldown = 30000;
    let lastHealTime = 0;
    let healCooldownTimer = null;

    const CLASH_RULES = {
        'âš”ï¸': 'ğŸ›¡ï¸',  // ç æ“Šå…‹é­”æ³•
        'ğŸ›¡ï¸': 'ğŸš«',  // é­”æ³•å…‹ç›¾æ“Š
        'ğŸš«': 'âš”ï¸'   // ç›¾æ“Šå…‹ç æ“Š
    };

    const RING_ABILITIES = [
        {
            id: 'CRIT',
            name: 'å¹¸é‹æˆ’æŒ‡',
            desc: 'æé«˜æš´æ“Šæ©Ÿç‡ï¼Œç•¥å¾®æå‡é­”æ³•ç›¸é—œå‚·å®³',
            effect: (tier) => Math.random() < (0.10 + tier * 0.10)  // 20~50%
        },
        {
            id: 'HEAL',
            name: 'ç”Ÿå‘½æˆ’æŒ‡',
            desc: 'é˜²ç¦¦æˆåŠŸæ™‚å›å¾© HPï¼Œä¸¦æå‡é˜²ç¦¦',
            effect: (hero) => {
                const tier = hero.equipment.RING.tier;
                const heal = 8 + tier * 4;
                hero.hp = Math.min(hero.maxHp, hero.hp + heal);
                return heal;
            }
        },
        {
            id: 'DODGE',
            name: 'æ•æ·æŒ‡ç’°',
            desc: 'å¤§å¹…æå‡é–ƒé¿æ©Ÿç‡',
            effect: (hero) => 0.10 + hero.equipment.RING.tier * 0.08
        },
        {
            id: 'MAGIC',
            name: 'é­”å°æŒ‡ç’°',
            desc: 'å¤§å¹…æé«˜é­”æ³•ç›¸é—œå‚·å®³',
            effect: (tier) => MAGIC_RING_MAGIC_RATE[tier] || 0
        },
        {
            id: 'BERSERKER',
            name: 'ç‹‚æˆ°å£«æŒ‡ç’°',
            desc: 'çŠ§ç‰²æœ€å¤§HPæ›å–å¤§é‡ATKï¼Œç‰©ç†æ”»æ“Šæœ‰æ©Ÿæœƒå¤šæ®µæ”»æ“Š',
            effect: (tier) => {
                const ratios = [0, 0.30, 0.40, 0.50, 0.60];
                return ratios[tier] || 0;
            }
        },
        {
            id: 'BALANCE',
            name: 'å¹³è¡¡æŒ‡ç’°',
            desc: 'æå‡å¹³æ‰‹æ™‚å‹‡è€…ç²å‹çš„æ©Ÿç‡',
            effect: (tier) => 10 + tier * 10
        },
        { id: 'NONE', name: 'ç„¡', desc: 'ç„¡' }
    ];

    const WEAPON_AFFIX_POOL = [
        { id: 'W_EXTRA_HIT', name: 'è¿½åŠ æ”»æ“Š', desc: 'ç‰©ç†æ”»æ“Šæ™‚æœ‰ 20% æ©Ÿç‡å†è¿½åŠ ä¸€æ¬¡ç›¸åŒå‚·å®³ã€‚' },
        { id: 'W_ATK_UP',    name: 'éŠ³åˆ©ä¹‹åˆƒ', desc: 'å¢åŠ å°‘é‡ç‰©ç†æ”»æ“ŠåŠ›ã€‚' },
        { id: 'W_MAGIC_UP',  name: 'é­”åŠ›å°ç®¡', desc: 'å¢åŠ å°‘é‡é­”æ³•æ”»æ“ŠåŠ›ã€‚' },
        { id: 'W_ARMOR_PEN', name: 'ç ´ç”²',     desc: 'ç‰©ç†æ”»æ“Šæ™‚ç•¥å¾®ç„¡è¦–æ•µäººé˜²ç¦¦ã€‚' },
        { id: 'W_LIFESTEAL', name: 'å¸è¡€',     desc: 'ç‰©ç†æ”»æ“Šé€ æˆçš„å‚·å®³æœƒå›å¾©éƒ¨åˆ† HPã€‚' },
        { id: 'W_BALANCE',   name: 'æˆ°é¬¥æœ¬èƒ½', desc: 'å¹³æ‰‹æ™‚ç¨å¾®æé«˜æˆ‘æ–¹åˆ¤å®šå‹ç‡ã€‚' }
    ];

    const SHIELD_AFFIX_POOL = [
        { id: 'S_BLOCK',        name: 'æ ¼æ“‹',       desc: 'å—åˆ°å‚·å®³æ™‚æœ‰ 20% æ©Ÿç‡æ¸›å°‘ 50% å‚·å®³ã€‚' },
        { id: 'S_MAGIC_GUARD',  name: 'é­”åŠ›è­·ç½©',   desc: 'æ–½æ”¾é­”æ³• / ç›¾æ“Šæ™‚æœ‰ 20% æ©Ÿç‡ç²å¾— 3 å›åˆ 50% æ¸›å‚·æ•ˆæœã€‚' },
        { id: 'S_DEF_UP',       name: 'åšé‡è­·ç”²',   desc: 'æé«˜å°‘é‡é˜²ç¦¦åŠ›ã€‚' },
        { id: 'S_TIE_UP',       name: 'å†·éœåˆ¤æ–·',   desc: 'ç¨å¾®æé«˜å¹³æ‰‹å‹ç‡ã€‚' },
        { id: 'S_REFLECT',      name: 'èŠæ£˜è­·ç›¾',   desc: 'å—åˆ°å‚·å®³æ™‚åå½ˆéƒ¨åˆ†å‚·å®³çµ¦æ•µäººã€‚' },
        { id: 'S_DODGE_UP',     name: 'éˆå·§é˜²ç¦¦',   desc: 'æé«˜å°‘é‡é–ƒé¿ç‡ã€‚' }
    ];

    function findAffix(pool, id) {
        return pool.find(a => a.id === id);
    }

    function addRandomAffixToWeaponRefine() {
        const existing = new Set(hero.weaponRefineAffixes);
        const candidates = WEAPON_AFFIX_POOL.filter(a => !existing.has(a.id));
        if (candidates.length === 0) return;
        const chosen = candidates[Math.floor(Math.random() * candidates.length)];
        hero.weaponRefineAffixes.push(chosen.id);
    }

    function updateWeaponRefineAffixes() {
        const targetSlots = Math.floor(hero.weaponRefineLevel / 5);
        if (targetSlots > hero.weaponRefineSlots) {
            for (let i = 0; i < targetSlots - hero.weaponRefineSlots; i++) {
                addRandomAffixToWeaponRefine();
            }
        } else if (targetSlots < hero.weaponRefineSlots) {
            for (let i = 0; i < hero.weaponRefineSlots - targetSlots; i++) {
                if (hero.weaponRefineAffixes.length > 0) hero.weaponRefineAffixes.pop();
            }
        }
        hero.weaponRefineSlots = targetSlots;
    }

    function addRandomAffix(equip, pool) {
        if (!equip.affixes) equip.affixes = [];
        const existing = new Set(equip.affixes);
        const candidates = pool.filter(a => !existing.has(a.id));
        if (candidates.length === 0) return;
        const chosen = candidates[Math.floor(Math.random() * candidates.length)];
        equip.affixes.push(chosen.id);
    }

    function updateShieldRefineAffixes(equip) {
        if (!equip) return;
        if (equip.refine == null) equip.refine = 0;
        if (equip.refineSlots == null) equip.refineSlots = 0;
        const targetSlots = Math.floor(equip.refine / 5);
        if (targetSlots > equip.refineSlots) {
            for (let i = 0; i < targetSlots - equip.refineSlots; i++) {
                addRandomAffix(equip, SHIELD_AFFIX_POOL);
            }
        } else if (targetSlots < equip.refineSlots) {
            for (let i = 0; i < equip.refineSlots - targetSlots; i++) {
                if (equip.affixes && equip.affixes.length > 0) equip.affixes.pop();
            }
        }
        equip.refineSlots = targetSlots;
    }

    const RARITY_COLORS = {
        'Normal': 'Rarity-Normal',
        'Magic': 'Rarity-Magic',
        'Rare': 'Rarity-Rare',
        'Epic': 'Rarity-Epic',
        'Legendary': 'Rarity-Legendary',
        'Mythic': 'Rarity-Mythic'
    };

    // å°æ€ª/ç‹ï¼šåŠ å…¥ mDef èˆ‡ dodge
    const ENEMIES = {
        SMALL: [
            { name: "å“¥å¸ƒæ—", hp: 30, atk: 12, def: 6,  mDef: 6,  dodge: 5,  lootChance: 0.6, exp: 8,  bias: { 'âš”ï¸': 0.4, 'ğŸ›¡ï¸': 0.3, 'ğŸš«': 0.3 } },
            { name: "éª·é«å…µ", hp: 35, atk: 10, def: 14, mDef: 4,  dodge: 6,  lootChance: 0.6, exp: 10, bias: { 'âš”ï¸': 0.3, 'ğŸ›¡ï¸': 0.3, 'ğŸš«': 0.4 } },
            { name: "é‡ç‹¼",  hp: 40, atk: 11, def: 4,  mDef: 16, dodge: 12, lootChance: 0.6, exp: 11, bias: { 'âš”ï¸': 0.6, 'ğŸ›¡ï¸': 0.2, 'ğŸš«': 0.2 } },
            { name: "çŸ³é ­äºº", hp: 50, atk: 8,  def: 22, mDef: 3,  dodge: 2,  lootChance: 0.5, exp: 14, bias: { 'âš”ï¸': 0.1, 'ğŸ›¡ï¸': 0.6, 'ğŸš«': 0.3 } },
            { name: "è™è ", hp: 24, atk: 15, def: 3,  mDef: 20, dodge: 20, lootChance: 0.7, exp: 7,  bias: { 'âš”ï¸': 0.3, 'ğŸ›¡ï¸': 0.4, 'ğŸš«': 0.3 } }
        ],
        BOSS: [
            { level: 1, name: "ä¸æ­»å·«å¦–", hp: 200, atk: 20, def: 10, mDef: 22, dodge: 10, lootChance: 1.0, exp: 70,  bias: { 'âš”ï¸': 0.4, 'ğŸ›¡ï¸': 0.3, 'ğŸš«': 0.3 } },
            { level: 2, name: "ç«ç„°å·¨é¾", hp: 380, atk: 28, def: 24, mDef: 12, dodge: 12, lootChance: 1.0, exp: 160, bias: { 'âš”ï¸': 0.5, 'ğŸ›¡ï¸': 0.2, 'ğŸš«': 0.3 } },
            { level: 3, name: "é å¤é­”ç¥", hp: 650, atk: 45, def: 26, mDef: 26, dodge: 15, lootChance: 1.0, exp: 380, bias: { 'âš”ï¸': 0.3, 'ğŸ›¡ï¸': 0.3, 'ğŸš«': 0.4 } }
        ]
    };

    const ENEMY_ART = {
        "å“¥å¸ƒæ—": [
            "",
            "/ï¼¼__/ï¼¼",
            "( o.o >",
            "( ^ )",
            "ï¼¼--/"
        ],
        "éª·é«å…µ": [
            "",
            " .-.",
            "( o )",
            " ï¼¼ï¼¼_/",
            " /ï¼¼ï¼¼"
        ],
        "é‡ç‹¼": [
            "",
            "/ï¼¼/ï¼¼",
            "( o.o )",
            "( ^ )",
            "\\-_/"
        ],
        "çŸ³é ­äºº": [
            "",
            "| O O |",
            "| \\_/ |",
            "|_____|",
            "| | |"
        ],
        "è™è ": [
            "",
            "ï¼¿      ï¼¿ ",
            "ï¼‰ï¼¼^ ^/ (",
            " )ï¼¿ã€‚ã€‚)(",
            "  |_ï¸¸_|",
            " _/Â¯Â¯Â¯ï¼¼_"
        ],
        "ä¸æ­»å·«å¦–": [
            "",
            "    +--[âš°ï¸]--+       ",
            "   | ( ğŸ’€ ğŸ’€ ) |    ",
            "   |  /|v|\\  |    ",
            "   /  `-----'  \\   ",
            "  `-------------'   "
        ],
        "ç«ç„°å·¨é¾": [
            "",
            "    <~ğŸ”¥~>  <~ğŸ”¥~>  ",
            "   /  ( ğŸ‰ ğŸ‰ )  \\ ",
            "  |    |  v  |    | ",
            "   \\  /\\_/\\_/\\  /   ",
            "    `----------'    "
        ],
        "é å¤é­”ç¥": [
            "",
            "    /\\/\\/\\/\\/\\   ",
            "   ( ğŸ‘ï¸ [X] ğŸ‘ï¸ )  ",
            "  |  /  |w|  \\  |  ",
            "   \\ |  |V|  | /    ",
            "    `-----------'   "
        ]
    };

    const mainView = document.getElementById('main-view');
    const messageLog = document.getElementById('message-log');
    const heroAtkVal = document.getElementById('hero-atk-val');
    const heroDefVal = document.getElementById('hero-def-val');
    const heroMatkVal = document.getElementById('hero-matk-val');
    const heroDodgeVal = document.getElementById('hero-dodge-val');
    const heroTieWinRateVal = document.getElementById('hero-tie-win-rate-val');
    const heroCritVal = document.getElementById('hero-crit-val');

    const commandMenu = document.getElementById('command-menu');
    const decisionMenu = document.getElementById('decision-menu');
    const btnDecYes = document.getElementById('btn-decision-yes');
    const btnDecNo = document.getElementById('btn-decision-no');

    const btn1 = document.getElementById('btn-action-1');
    const btn2 = document.getElementById('btn-action-2');
    const btn3 = document.getElementById('btn-action-3');

    const eqWeapon = document.getElementById('eq-weapon');
    const eqShield = document.getElementById('eq-shield');
    const eqRing = document.getElementById('eq-ring');
    const eqDetailWeapon = document.getElementById('eq-detail-weapon');
    const eqDetailShield = document.getElementById('eq-detail-shield');
    const eqDetailRing = document.getElementById('eq-detail-ring');
    const eqWeaponAffix = document.getElementById('eq-weapon-affix');
    const eqShieldAffix = document.getElementById('eq-shield-affix');

    const heroHpSpan = document.getElementById('hero-hp');
    const heroMaxHpSpan = document.getElementById('hero-max-hp');
    const heroLevelSpan = document.getElementById('hero-level');
    const heroExpSpan = document.getElementById('hero-exp');
    const heroExpMaxSpan = document.getElementById('hero-exp-max');
    const weaponRefineLevelSpan = document.getElementById('weapon-refine-level');
    const shieldRefineLevelSpan = document.getElementById('shield-refine-level');
    const weaponMaterialsSpan = document.getElementById('weapon-materials');
    const shieldMaterialsSpan = document.getElementById('shield-materials');

    function randInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function getEffectivePower(eq, slotType) {
        if (!eq) return 0;
        let base = eq.power || 0;
        if (slotType === 'SHIELD' && eq.refine && eq.refine > 0) {
            const per = 0.08;
            base = Math.floor(base * (1 + eq.refine * per));
        }
        return base;
    }

    function getMagicAttackValue() {
        let magic = hero.currentMagicAtk;
        const ring = hero.equipment.RING;
        if (ring && ring.ability) {
            if (ring.ability.id === 'MAGIC') {
                const rate = MAGIC_RING_MAGIC_RATE[ring.tier] || 0;
                magic = Math.floor(magic * (1 + rate));
            } else if (ring.ability.id === 'CRIT') {
                const rate = CRIT_RING_MAGIC_RATE[ring.tier] || 0;
                magic = Math.floor(magic * (1 + rate));
            }
        }
        if (magic < 0) magic = 0;
        return magic;
    }

    function getHeroCritRate() {
        const ring = hero.equipment.RING;
        if (ring && ring.ability && ring.ability.id === 'CRIT') {
            return (0.10 + ring.tier * 0.10) * 100;
        }
        return 5;
    }

    function getWeaponRefineSuccessRate(nextRefineLevel) {
        if (nextRefineLevel <= 3) return 1.0;
        if (nextRefineLevel <= 7) return 0.85;
        if (nextRefineLevel <= 10) return 0.6;
        if (nextRefineLevel <= 12) return 0.4;
        if (nextRefineLevel <= 15) return 0.25;
        return 0.15;
    }

    function attemptWeaponRefine() {
        const w = hero.equipment.WEAPON;
        if (!w || w.name === "å¾’æ‰‹") {
            log("â— ç›®å‰æ²’æœ‰å¯ç²¾ç·´çš„æ­¦å™¨ï¼ˆå¾’æ‰‹ä¸ç²¾ç·´ï¼‰ã€‚");
            return;
        }
        const nextRefine = hero.weaponRefineLevel + 1;
        const successRate = getWeaponRefineSuccessRate(nextRefine);
        const roll = Math.random();

        if (roll < successRate) {
            hero.weaponRefineLevel = nextRefine;
            log(`ğŸ›  æ­¦å™¨ç²¾ç·´æˆåŠŸï¼å…¨æ­¦å™¨ç²¾ç·´ç­‰ç´šæå‡ç‚º +${hero.weaponRefineLevel}ï¼ˆé­”æ³•æ”»æ“Šæå‡ï¼‰ã€‚`);
        } else {
            if (hero.weaponRefineLevel > 3) {
                const oldRefine = hero.weaponRefineLevel;
                hero.weaponRefineLevel = Math.max(3, hero.weaponRefineLevel - 1);
                log(`ğŸ’¥ æ­¦å™¨ç²¾ç·´å¤±æ•—ï¼ç²¾ç·´ç­‰ç´šå¾ +${oldRefine} é™ç‚º +${hero.weaponRefineLevel} (ä¿åº• +3)ã€‚`);
            } else {
                log(`ğŸ’¥ æ­¦å™¨ç²¾ç·´å¤±æ•—ï¼Œä½†å› ä¿åº• +3ï¼Œæ­¦å™¨ç²¾ç·´ç­‰ç´šä¸è®Šã€‚`);
            }
        }
        updateWeaponRefineAffixes();
    }

    function getShieldRefineSuccessRate(nextRefineLevel) {
        if (nextRefineLevel <= 3) return 1.0;
        if (nextRefineLevel <= 7) return 0.9;
        if (nextRefineLevel <= 10) return 0.7;
        if (nextRefineLevel <= 12) return 0.5;
        return 0.3;
    }

    function attemptShieldRefine() {
        const s = hero.equipment.SHIELD;
        if (!s || s.name === "ç„¡") {
            log("â— ç›®å‰æ²’æœ‰å¯ç²¾ç·´çš„ç›¾ç‰Œã€‚");
            return;
        }
        if (!s.refine) s.refine = 0;
        const nextRefine = s.refine + 1;
        const successRate = getShieldRefineSuccessRate(nextRefine);
        const roll = Math.random();

        if (roll < successRate) {
            s.refine = nextRefine;
            log(`ğŸ›¡ ç›¾ç‰Œç²¾ç·´æˆåŠŸï¼${s.name} ç²¾ç·´ +${s.refine}ï¼ˆé˜²ç¦¦æå‡ï¼‰ã€‚`);
        } else {
            if (s.refine > 3) {
                const oldRefine = s.refine;
                s.refine = Math.max(3, s.refine - 1);
                log(`ğŸ’¥ ç›¾ç‰Œç²¾ç·´å¤±æ•—ï¼ç²¾ç·´ç­‰ç´šå¾ +${oldRefine} é™ç‚º +${s.refine} (ä¿åº• +3)ã€‚`);
            } else {
                log(`ğŸ’¥ ç›¾ç‰Œç²¾ç·´å¤±æ•—ï¼Œä½†å› ä¿åº• +3ï¼Œç›¾ç‰Œç²¾ç·´ç­‰ç´šä¸è®Šã€‚`);
            }
        }
        updateShieldRefineAffixes(s);
    }

    function log(message) {
        const div = document.createElement('div');
        div.className = 'log-msg';
        div.innerHTML = `> ${message}`;
        messageLog.prepend(div);
        if (messageLog.children.length > 40) {
            messageLog.removeChild(messageLog.lastChild);
        }
    }

    function calculateHeroStats() {
        const weaponPower = getEffectivePower(hero.equipment.WEAPON, 'WEAPON');
        const shieldPower = getEffectivePower(hero.equipment.SHIELD, 'SHIELD');

        hero.currentAttack = hero.baseAttack + weaponPower;
        hero.currentDefense = hero.baseDefense + shieldPower;
        hero.healRingDefBonus = 0;

        if (hero.equipment.RING.ability && hero.equipment.RING.ability.id === 'HEAL') {
            const tier = hero.equipment.RING.tier;
            const ratio = Math.min(0.20, 0.05 * tier);
            const extraDef = Math.floor(hero.currentDefense * ratio);
            hero.currentDefense += extraDef;
            hero.healRingDefBonus = extraDef;
        }

        let ringDodgeBonus = 0;
        if (hero.equipment.RING.ability && hero.equipment.RING.ability.id === 'DODGE') {
            ringDodgeBonus = hero.equipment.RING.ability.effect(hero) * 100;
        }

        hero.currentTieWinRate = hero.baseTieWinRate;
        if (hero.equipment.RING.ability && hero.equipment.RING.ability.id === 'BALANCE') {
            hero.currentTieWinRate += hero.equipment.RING.ability.effect(hero.equipment.RING.tier);
        }

        const shield = hero.equipment.SHIELD;
        if (shield && shield.affixes) {
            if (shield.affixes.includes('S_DEF_UP')) {
                hero.currentDefense = Math.floor(hero.currentDefense * 1.10);
            }
            if (shield.affixes.includes('S_TIE_UP')) {
                hero.currentTieWinRate += 5;
            }
            if (shield.affixes.includes('S_DODGE_UP')) {
                ringDodgeBonus += 5;
            }
        }

        hero.currentTieWinRate = Math.min(100, hero.currentTieWinRate);
        hero.berserkerBonus = 0;
        hero.berserkerPenalty = 0;

        if (hero.equipment.RING.ability && hero.equipment.RING.ability.id === 'BERSERKER') {
            const tier = hero.equipment.RING.tier;
            const ratio = hero.equipment.RING.ability.effect(tier);
            const hpToAtk = Math.floor(hero.maxHp * ratio);
            const defReduction = Math.floor(hero.currentDefense * 0.15);
            hero.currentAttack += hpToAtk;
            hero.currentDefense -= defReduction;
            hero.berserkerBonus = hpToAtk;
            hero.berserkerPenalty = defReduction;
        }

        hero.currentDefense = Math.max(0, hero.currentDefense);

        hero.currentDodge = hero.baseDodge + ringDodgeBonus;
        hero.currentDodge = Math.min(80, hero.currentDodge);

        const rarity = hero.equipment.WEAPON.rarity || 'Normal';
        const per = MAGIC_REFINE_BONUS[rarity] || 0;
        hero.currentMagicAtk = hero.baseMagicAtk + hero.weaponRefineLevel * per;
        if (hero.currentMagicAtk < 0) hero.currentMagicAtk = 0;
    }

    function getAllWeaponAffixNames() {
        const ids = new Set();
        (hero.equipment.WEAPON.affixes || []).forEach(id => ids.add(id));
        (hero.weaponRefineAffixes || []).forEach(id => ids.add(id));
        if (ids.size === 0) return 'ç„¡';
        return Array.from(ids).map(id => {
            const a = findAffix(WEAPON_AFFIX_POOL, id);
            return a ? a.name : id;
        }).join('ã€');
    }

    function getShieldAffixNames() {
        const s = hero.equipment.SHIELD;
        if (!s || !s.affixes || s.affixes.length === 0) return 'ç„¡';
        return s.affixes.map(id => {
            const a = findAffix(SHIELD_AFFIX_POOL, id);
            return a ? a.name : id;
        }).join('ã€');
    }

    function updateStatus() {
        calculateHeroStats();

        heroHpSpan.textContent = Math.max(0, hero.hp);
        heroMaxHpSpan.textContent = hero.maxHp;
        heroLevelSpan.textContent = hero.level;
        heroExpSpan.textContent = hero.exp;
        heroExpMaxSpan.textContent = hero.expToNextLevel;

        heroAtkVal.textContent = hero.currentAttack;
        heroDefVal.textContent = hero.currentDefense;
        heroMatkVal.textContent = getMagicAttackValue();
        heroDodgeVal.textContent = hero.currentDodge.toFixed(1);
        heroTieWinRateVal.textContent = hero.currentTieWinRate.toFixed(1);
        heroCritVal.textContent = getHeroCritRate().toFixed(1);

        const wEq = hero.equipment.WEAPON;
        const sEq = hero.equipment.SHIELD;
        const rEq = hero.equipment.RING;

        const effW = getEffectivePower(wEq, 'WEAPON');
        const effS = getEffectivePower(sEq, 'SHIELD');

        eqWeapon.innerHTML = `<span class="${RARITY_COLORS[wEq.rarity]}">${wEq.name}</span>`;
        eqShield.innerHTML = `<span class="${RARITY_COLORS[sEq.rarity]}">${sEq.name}${sEq.refine ? ' +' + sEq.refine : ''}</span>`;
        eqRing.innerHTML = `<span class="${RARITY_COLORS[rEq.rarity]}">${rEq.name}</span>`;

        eqDetailWeapon.innerHTML =
            `<span class="${RARITY_COLORS[wEq.rarity]}">æ”»æ“ŠåŠ› +${effW}ï¼Œé­”æ”» +${getMagicAttackValue()}</span>`;
        eqDetailShield.innerHTML =
            `<span class="${RARITY_COLORS[sEq.rarity]}">é˜²ç¦¦åŠ› +${effS}${sEq.refine ? ` (ç²¾ç·´+${sEq.refine})` : ''}</span>`;

        let ringDetailText = `ç‰¹æ•ˆï¼š${rEq.ability.desc} (Lv.${rEq.tier})`;
        const ringId = rEq.ability.id;
        const tier = rEq.tier;

        if (ringId === 'BERSERKER') {
            ringDetailText += `<span style="color:red;"> (ATK+${hero.berserkerBonus}, DEF-${hero.berserkerPenalty}ï¼Œç‰©æ”»æœ‰æ©Ÿæœƒå¤šæ®µæ”»æ“Š)</span>`;
        } else if (ringId === 'HEAL' && hero.healRingDefBonus > 0) {
            const extraRatio = Math.min(0.20, 0.05 * tier) * 100;
            ringDetailText += `<span style="color:#2196F3;"> (é˜²ç¦¦+${hero.healRingDefBonus}ï¼Œé˜²ç¦¦åŠ æˆç´„ +${extraRatio.toFixed(0)}%)</span>`;
        } else if (ringId === 'MAGIC') {
            const rate = (MAGIC_RING_MAGIC_RATE[tier] || 0) * 100;
            ringDetailText += `<span style="color:#9c27b0;"> (é­”æ³•å‚·å®³ +${rate.toFixed(0)}%)</span>`;
        } else if (ringId === 'CRIT') {
            const critRate = getHeroCritRate();
            const mRate = (CRIT_RING_MAGIC_RATE[tier] || 0) * 100;
            ringDetailText += `<span style="color:#ff9800;"> (çˆ†æ“Šç‡ç´„ ${critRate.toFixed(0)}%ï¼Œé­”æ³•å‚·å®³ +${mRate.toFixed(0)}%)</span>`;
        } else if (ringId === 'DODGE') {
            ringDetailText += `<span style="color:#4caf50;"> (ç›®å‰é–ƒé¿ç´„ ${hero.currentDodge.toFixed(1)}%)</span>`;
        } else if (ringId === 'BALANCE') {
            ringDetailText += `<span style="color:#03a9f4;"> (å¹³æ‰‹å‹ç‡ç›®å‰ç´„ ${hero.currentTieWinRate.toFixed(1)}%)</span>`;
        } else if (ringId === 'NONE') {
            ringDetailText = `ç‰¹æ•ˆï¼šç„¡ (Lv.0)`;
        }
        eqDetailRing.innerHTML = `<span class="${RARITY_COLORS[rEq.rarity]}">${ringDetailText}</span>`;

        eqWeaponAffix.innerHTML = getAllWeaponAffixNames();
        eqShieldAffix.innerHTML = getShieldAffixNames();

        weaponRefineLevelSpan.textContent = hero.weaponRefineLevel;
        shieldRefineLevelSpan.textContent = getShieldRefineLevel();
        weaponMaterialsSpan.textContent = weaponMaterials;
        shieldMaterialsSpan.textContent = shieldMaterials;
    }

    function setCommands(c1, c2, c3, actionHandler, state) {
        btn1.textContent = c1.text;
        btn2.textContent = c2.text;
        btn3.textContent = c3.text;

        btn1.onclick = () => actionHandler(c1.value);
        btn2.onclick = () => actionHandler(c2.value);
        btn3.onclick = () => actionHandler(c3.value);

        btn1.classList.remove('defend-btn');
        btn2.classList.remove('defend-btn');
        btn3.classList.remove('defend-btn');

        commandMenu.style.display = 'flex';
        decisionMenu.style.display = 'none';

        if (state === 'BATTLE') {
            if (c3.value === 'ğŸš«') btn3.classList.add('defend-btn');
            commandMenu.querySelectorAll('.command-btn').forEach(btn => btn.disabled = false);
        } else if (state === 'MAP') {
            commandMenu.querySelectorAll('.command-btn').forEach(btn => btn.disabled = false);
            checkHealCooldown();
        }
    }

    function flashBattleView(type) {
        let className = 'hero-hit-flash';
        if (type === 'crit') className = 'crit-flash';
        else if (type === 'heal') className = 'heal-flash';
        else if (type === 'monster-hit') className = 'monster-hit-flash';

        mainView.classList.add(className);
        setTimeout(() => mainView.classList.remove(className), 300);
    }

    function battleTransition(callback) {
        mainView.innerHTML = `<h1>é€²å…¥æˆ°é¬¥...</h1>`;
        disableCommands(true);
        let count = 0;
        const interval = setInterval(() => {
            if (count % 2 === 0) {
                mainView.classList.remove('transition-flash-off');
                mainView.classList.add('transition-flash-on');
            } else {
                mainView.classList.remove('transition-flash-on');
                mainView.classList.add('transition-flash-off');
            }
            count++;
            if (count > 5) {
                clearInterval(interval);
                mainView.classList.remove('transition-flash-on', 'transition-flash-off');
                mainView.style.backgroundColor = '#1a2a3a';
                callback();
            }
        }, 200);
    }

    function showLootAnimation(loot) {
        return new Promise(resolve => {
            const rarityClass = `loot-${loot.rarity}`;
            mainView.classList.add(rarityClass);
            mainView.innerHTML = `
                <p style="text-shadow: 0 0 10px currentColor;">âœ¨ ç²å¾—æ–°å¯¶ç‰©! âœ¨</p>
                <p>${loot.name}</p>
            `;
            setTimeout(() => {
                mainView.classList.remove(rarityClass);
                mainView.style.backgroundColor = '#1a2a3a';
                resolve();
            }, 1500);
        });
    }

    function enterMap() {
        if (gameState === 'CREDITS') {
            mainView.style.whiteSpace = 'pre';
        }
        gameState = 'MAP';
        updateStatus();
        mainView.style.backgroundColor = '#1a2a3a';
        mainView.innerHTML = `<p>ğŸ—ºï¸ å‹‡è€… ${hero.name} (Lv.${hero.level})ï¼Œè«‹é¸æ“‡ä½ çš„ä¸‹ä¸€æ­¥è¡Œå‹•ï¼š</p>`;

        const maxBossLevel = ENEMIES.BOSS.length;
        let c2Text;
        if (bossLevel > maxBossLevel) {
            c2Text = "ğŸ‰ å·²æ“Šæ•—æ‰€æœ‰ Boss";
            btn2.disabled = true;
        } else {
            c2Text = `æŒ‘æˆ° Boss ${bossLevel} å¯¶è—`;
            btn2.disabled = false;
        }

        setCommands(
            { text: "æ¢ç´¢ (æ‰¾å°æ€ª)", value: 'Small' },
            { text: c2Text, value: 'Boss' },
            { text: "ä¼‘æ¯ (æ¢å¾© HP)", value: 'Heal' },
            handleMapAction,
            'MAP'
        );
    }

    function checkHealCooldown() {
        const healBtn = btn3;
        const now = Date.now();
        const remaining = (lastHealTime + healCooldown) - now;
        if (remaining > 0) {
            setHealCooldown(remaining);
        } else {
            healBtn.textContent = 'ä¼‘æ¯ (æ¢å¾© HP)';
            healBtn.disabled = false;
            clearInterval(healCooldownTimer);
        }
    }

    function setHealCooldown(initialRemaining) {
        const healBtn = btn3;
        if (gameState === 'MAP') healBtn.disabled = true;
        clearInterval(healCooldownTimer);

        let remainingSeconds = Math.ceil(initialRemaining / 1000);
        healCooldownTimer = setInterval(() => {
            if (remainingSeconds <= 0) {
                clearInterval(healCooldownTimer);
                if (gameState === 'MAP') {
                    healBtn.textContent = 'ä¼‘æ¯ (æ¢å¾© HP)';
                    healBtn.disabled = false;
                }
            } else {
                if (gameState === 'MAP') {
                    healBtn.textContent = `ä¼‘æ¯ (${remainingSeconds}s)`;
                }
                remainingSeconds--;
            }
        }, 1000);

        if (remainingSeconds > 0 && gameState === 'MAP') {
            healBtn.textContent = `ä¼‘æ¯ (${remainingSeconds}s)`;
        }
    }

    function handleMapAction(action) {
        if (gameState !== 'MAP') return;

        if (action === 'Small') {
            const index = Math.floor(Math.random() * ENEMIES.SMALL.length);
            const enemyData = ENEMIES.SMALL[index];
            const levelFactor = 1 + (hero.level - 1) * 0.15;
            const scaledHp   = Math.floor(enemyData.hp   * levelFactor);
            const scaledAtk  = Math.floor(enemyData.atk  * levelFactor);
            const scaledDef  = Math.floor((enemyData.def  || 0) * (1 + (hero.level - 1) * 0.10));
            const scaledMDef = Math.floor((enemyData.mDef || enemyData.def || 0) * (1 + (hero.level - 1) * 0.10));

            currentEnemy = {
                ...enemyData,
                originalHp: scaledHp,
                hp: scaledHp,
                atk: scaledAtk,
                def: scaledDef,
                mDef: scaledMDef
            };
            battleTransition(enterBattle);
        } else if (action === 'Boss') {
            if (bossLevel > ENEMIES.BOSS.length) return;
            const enemyData = ENEMIES.BOSS[bossLevel - 1];

            const effectiveLevel = Math.max(hero.level, enemyData.level * 5);
            const levelFactor = 1 + (effectiveLevel - 1) * 0.15;

            const scaledHp   = Math.floor(enemyData.hp   * levelFactor);
            const scaledAtk  = Math.floor(enemyData.atk  * levelFactor);
            const scaledDef  = Math.floor((enemyData.def  || 0) * (1 + (effectiveLevel - 1) * 0.08));
            const scaledMDef = Math.floor((enemyData.mDef || enemyData.def || 0) * (1 + (effectiveLevel - 1) * 0.08));

            currentEnemy = {
                ...enemyData,
                originalHp: scaledHp,
                hp: scaledHp,
                atk: scaledAtk,
                def: scaledDef,
                mDef: scaledMDef
            };
            battleTransition(enterBattle);
        } else if (action === 'Heal') {
            const now = Date.now();
            if (now - lastHealTime < healCooldown) {
                const remainingSec = Math.ceil((healCooldown - (now - lastHealTime)) / 1000);
                log(`â±ï¸ ä¼‘æ¯å†·å»ä¸­! å°šé¤˜ ${remainingSec} ç§’ã€‚`);
                return;
            }
            const baseHeal = 5 + Math.floor(Math.random() * 5);
            const magicBonus = Math.floor(getMagicAttackValue() / 10);
            const healAmount = baseHeal + magicBonus;
            hero.hp = Math.min(hero.maxHp, hero.hp + healAmount);
            log(`ğŸ™ åœ¨è’é‡ä¸­ä¼‘æ¯ã€‚æ¢å¾©äº† ${healAmount} é» HPã€‚(é­”æ”»åŠ æˆ +${magicBonus})`);
            flashBattleView('heal');
            updateStatus();

            lastHealTime = now;
            setHealCooldown(healCooldown);
        }
    }

    function enterBattle() {
        gameState = 'BATTLE';
        log(`é­é‡äº† ${currentEnemy.name}! è«‹é¸æ“‡ä½ çš„æ‹›å¼!`);
        updateBattleView();
        setCommands(
            { text: "âš”ï¸ ç æ“Š (ç‰©ç†)", value: 'âš”ï¸' },
            { text: "ğŸª„ é­”æ³•æ”»æ“Š (å¿…ä¸­)", value: 'ğŸ›¡ï¸' },
            { text: "ğŸ›¡ï¸ ç›¾æ“Š (DEF ç„¡è¦–é˜²ç¦¦)", value: 'ğŸš«' },
            handleBattleAction,
            'BATTLE'
        );
        disableCommands(false);
    }

    function updateBattleView() {
        const art = ENEMY_ART[currentEnemy.name] || ENEMY_ART["éª·é«å…µ"];
        mainView.innerHTML = `
${currentEnemy.name}
HP: ${Math.max(0, currentEnemy.hp)}/${currentEnemy.originalHp}

${art.join('\n')}
        `;
        updateStatus();
    }

    function applyHeroAttackEffects(baseDamage, isPhysical) {
        let totalDamage = baseDamage;
        let hits = 1;

        const ring = hero.equipment.RING;
        const tier = ring.tier;

        if (isPhysical && ring.ability && ring.ability.id === 'BERSERKER') {
            const multiChance = BERSERKER_MULTI_HIT_CHANCE[tier] || 0;
            const thirdChance = BERSERKER_THIRD_HIT_CHANCE[tier] || 0;
            if (Math.random() < multiChance) {
                hits++;
                if (Math.random() < thirdChance) hits++;
            }
            if (hits > 1) {
                log(`ğŸ©¸ ç‹‚æˆ°å£«æŒ‡ç’°ç™¼å‹•ï¼æœ¬æ¬¡æ”»æ“Šå…± ${hits} é€£æ“Šï¼`);
            }
        }

        const weapon = hero.equipment.WEAPON;
        const allAffixes = new Set([
            ...(weapon.affixes || []),
            ...(hero.weaponRefineAffixes || [])
        ]);

        if (isPhysical && allAffixes.has('W_EXTRA_HIT')) {
            if (Math.random() < 0.2) {
                hits++;
                log(`âš”ï¸ æ­¦å™¨è¿½åŠ æ”»æ“Šè©æ¢è§¸ç™¼ï¼Œå¤šæ‰“äº†ä¸€ä¸‹ï¼`);
            }
        }

        totalDamage = baseDamage * hits;

        if (allAffixes.has('W_LIFESTEAL') && totalDamage > 0) {
            const heal = Math.max(1, Math.floor(totalDamage * 0.2));
            hero.hp = Math.min(hero.maxHp, hero.hp + heal);
            log(`ğŸ©¸ æ­¦å™¨å¸è¡€æ•ˆæœï¼Œå›å¾© ${heal} é» HPï¼`);
        }

        return totalDamage;
    }

    function tryTriggerMagicGuard() {
        const shield = hero.equipment.SHIELD;
        if (shield && shield.affixes && shield.affixes.includes('S_MAGIC_GUARD')) {
            if (Math.random() < 0.2) {
                hero.magicGuardTurns = 3;
                log('âœ¨ ç›¾ç‰Œã€Œé­”åŠ›è­·ç½©ã€å•Ÿå‹•ï¼æ¥ä¸‹ä¾† 3 å›åˆå—åˆ°çš„å‚·å®³æ¸›åŠã€‚');
            }
        }
    }

    function applyDamageToHero(rawDamage) {
        let dmg = rawDamage;
        const shield = hero.equipment.SHIELD;

        if (hero.magicGuardTurns && hero.magicGuardTurns > 0) {
            dmg = Math.floor(dmg * 0.5);
            hero.magicGuardTurns--;
            if (hero.magicGuardTurns === 0) {
                log('ğŸ”š é­”åŠ›è­·ç½©æ•ˆæœçµæŸã€‚');
            }
        }
        if (shield && shield.affixes && shield.affixes.includes('S_BLOCK')) {
            if (Math.random() < 0.2) {
                dmg = Math.floor(dmg * 0.5);
                log('ğŸ›¡ï¸ ç›¾ç‰Œæ ¼æ“‹ï¼æœ¬æ¬¡å‚·å®³æ¸›åŠã€‚');
            }
        }
        if (shield && shield.affixes && shield.affixes.includes('S_REFLECT') && dmg > 0) {
            const reflect = Math.max(1, Math.floor(dmg * 0.2));
            currentEnemy.hp -= reflect;
            log(`ğŸ” èŠæ£˜è­·ç›¾åå½ˆ ${reflect} é»å‚·å®³çµ¦ ${currentEnemy.name}ï¼`);
        }
        hero.hp -= Math.max(1, dmg);
        return dmg;
    }

    // â˜… æ€ªç‰©é–ƒé¿ï¼šåªæœƒé–ƒ ç æ“Š & ç›¾æ“Šï¼Œé­”æ³•æ”»æ“Šå¿…å®šå‘½ä¸­
    function enemyDodged(playerMove) {
        if (playerMove === 'ğŸ›¡ï¸') return false; // é­”æ³•æ”»æ“Šå¿…ä¸­
        const dodge = currentEnemy.dodge || 0;
        return Math.random() * 100 < dodge;
    }

    async function handleBattleAction(playerMove) {
        if (gameState !== 'BATTLE') return;
        disableCommands(true);
        let battleEnded = false;

        try {
            const bias = currentEnemy.bias;
            let monsterMove = '';
            const r = Math.random();
            let cumulative = 0;
            if (r < (cumulative += bias['âš”ï¸'])) monsterMove = 'âš”ï¸';
            else if (r < (cumulative += bias['ğŸ›¡ï¸'])) monsterMove = 'ğŸ›¡ï¸';
            else monsterMove = 'ğŸš«';

            log(`--- é›™æ–¹åŒæ™‚å‡ºæ‹› ---`);
            log(`å‹‡è€…å‡ºæ‹›: ${playerMove} | æ€ªç‰©å‡ºæ‹›: ${monsterMove}`);

            const isHeroWin    = CLASH_RULES[playerMove] === monsterMove;
            const isMonsterWin = CLASH_RULES[monsterMove] === playerMove;

            const baseSwordDmg  = Math.max(1, hero.currentAttack - (currentEnemy.def || 0));
            const baseMagicDmg  = Math.max(1, getMagicAttackValue() - (currentEnemy.mDef || currentEnemy.def || 0));
            const SHIELD_DMG    = Math.max(1, hero.currentDefense); // ç›¾æ“Š=DEFï¼Œå®Œå…¨ç„¡è¦–é˜²ç¦¦

            if (isHeroWin) {
                let damage = 0;
                let isPhysical = false;
                let isMagic = false;

                if (playerMove === 'âš”ï¸') {
                    damage = baseSwordDmg;
                    isPhysical = true;
                } else if (playerMove === 'ğŸ›¡ï¸') {
                    damage = baseMagicDmg;
                    isMagic = true;
                } else if (playerMove === 'ğŸš«') {
                    damage = SHIELD_DMG;
                    isPhysical = true;
                    if (currentEnemy.name === 'çŸ³é ­äºº') {
                        damage *= 2;
                        log('ğŸ’¥ çŸ³é ­äººç‰¹åˆ¥æ€•ç›¾æ“Šï¼Œç›¾æ“Šå‚·å®³åŠ å€ï¼');
                    }
                }

                if (enemyDodged(playerMove)) {
                    log(`ğŸ˜ˆ ${currentEnemy.name} æˆåŠŸé–ƒé¿äº†ä½ çš„æ”»æ“Šï¼`);
                    damage = 0;
                } else {
                    const ring = hero.equipment.RING;
                    if (isPhysical &&
                        ring.ability &&
                        ring.ability.id === 'CRIT' &&
                        ring.ability.effect(ring.tier)) {
                        damage = Math.floor(damage * 2);
                        log(`âš¡ æˆ’æŒ‡æ•ˆæœå•Ÿå‹•: æš´æ“Š!`);
                        flashBattleView('crit');
                    }
                    if (isPhysical && damage > 0) {
                        damage = applyHeroAttackEffects(damage, true);
                    }
                    if (playerMove === 'ğŸ›¡ï¸' || playerMove === 'ğŸš«') {
                        tryTriggerMagicGuard();
                    }
                    currentEnemy.hp -= damage;
                    log(`âœ… å‹‡è€… ${playerMove} è´äº† ${monsterMove}ï¼Œé€ æˆ ${damage} é»å‚·å®³!`);
                    flashBattleView('hero-hit');
                }
            } else if (playerMove === monsterMove) {
                log(`ğŸ¤ é›™æ–¹å‡ºæ‹›ç›¸åŒ (${playerMove})ï¼Œé€²å…¥å¹³æ‰‹æ©Ÿç‡åˆ¤å®š!`);
                const tieWinChance = hero.currentTieWinRate / 100;
                if (Math.random() < tieWinChance) {
                    log(`âœ¨ åˆ¤å®šæˆåŠŸ! å‹‡è€…ç²å¾—å„ªå‹¢!`);

                    let damage = 0;
                    let isPhysical = false;
                    let isMagic = false;

                    if (playerMove === 'âš”ï¸') {
                        damage = baseSwordDmg;
                        isPhysical = true;
                    } else if (playerMove === 'ğŸ›¡ï¸') {
                        damage = baseMagicDmg;
                        isMagic = true;
                    } else if (playerMove === 'ğŸš«') {
                        damage = SHIELD_DMG;
                        isPhysical = true;
                        if (currentEnemy.name === 'çŸ³é ­äºº') {
                            damage *= 2;
                            log('ğŸ’¥ çŸ³é ­äººç‰¹åˆ¥æ€•ç›¾æ“Šï¼Œç›¾æ“Šå‚·å®³åŠ å€ï¼');
                        }
                    }

                    if (enemyDodged(playerMove)) {
                        log(`ğŸ˜ˆ ${currentEnemy.name} åœ¨å¹³æ‰‹åˆ¤å®šä¸­æˆåŠŸé–ƒé¿ä½ çš„æ”»æ“Šï¼`);
                        damage = 0;
                    } else {
                        const ring = hero.equipment.RING;
                        if (isPhysical &&
                            ring.ability &&
                            ring.ability.id === 'CRIT' &&
                            ring.ability.effect(ring.tier)) {
                            damage = Math.floor(damage * 2);
                            log(`âš¡ æˆ’æŒ‡æ•ˆæœå•Ÿå‹•: æš´æ“Š!`);
                            flashBattleView('crit');
                        }
                        if (isPhysical && damage > 0) {
                            damage = applyHeroAttackEffects(damage, true);
                        }
                        if (playerMove === 'ğŸ›¡ï¸' || playerMove === 'ğŸš«') {
                            tryTriggerMagicGuard();
                        }
                        currentEnemy.hp -= damage;
                        log(`âœ… å‹‡è€…é€ æˆ ${damage} é»å‚·å®³!`);
                        flashBattleView('hero-hit');
                    }

                    if (playerMove === 'ğŸš«' && !enemyDodged('ğŸš«')) {
                        if (hero.equipment.RING.ability && hero.equipment.RING.ability.id === 'HEAL') {
                            const heal = hero.equipment.RING.ability.effect(hero);
                            log(`ğŸ’– ç”Ÿå‘½æˆ’æŒ‡: é˜²ç¦¦æˆåŠŸï¼Œæ¢å¾© ${heal} HP!`);
                            flashBattleView('heal');
                            updateStatus();
                        }
                    }
                } else {
                    log(`ğŸ’€ åˆ¤å®šå¤±æ•—... æ€ªç‰©ç²å¾—å„ªå‹¢!`);
                    let monsterDamage = Math.max(1, currentEnemy.atk - hero.currentDefense);
                    applyDamageToHero(monsterDamage);
                    log(`ğŸ’¥ æ€ªç‰©ç™¼å‹• ${monsterMove}ï¼Œé€ æˆ ${monsterDamage} é»å‚·å®³!`);
                    flashBattleView('monster-hit');
                }
            } else if (isMonsterWin) {
                log(`ğŸš« å‹‡è€… ${playerMove} è¢« ${monsterMove} å…‹åˆ¶ï¼Œæ‹›å¼è¢«æ“‹é–‹ã€‚`);
                if (playerMove === 'ğŸš«' && monsterMove === 'âš”ï¸') {
                    let damage = SHIELD_DMG;
                    if (currentEnemy.name === 'çŸ³é ­äºº') {
                        damage *= 2;
                        log('ğŸ’¥ çŸ³é ­äººç‰¹åˆ¥æ€•ç›¾æ“Šï¼Œç›¾æ“Šå‚·å®³åŠ å€ï¼');
                    }
                    if (enemyDodged('ğŸš«')) {
                        log(`ğŸ˜ˆ ${currentEnemy.name} é–ƒéäº†ä½ çš„ç›¾æ“Šåæ“Šï¼`);
                        damage = 0;
                    } else {
                        const ring = hero.equipment.RING;
                        if (ring.ability &&
                            ring.ability.id === 'CRIT' &&
                            ring.ability.effect(ring.tier)) {
                            damage = Math.floor(damage * 2);
                            log(`âš¡ æˆ’æŒ‡æ•ˆæœå•Ÿå‹•: æš´æ“Š!`);
                            flashBattleView('crit');
                        }
                        damage = applyHeroAttackEffects(damage, true);
                        tryTriggerMagicGuard();
                        currentEnemy.hp -= damage;
                        log(`ğŸ’¥ ç›¾æ“Šåæ“Š! é€ æˆ ${damage} é»å‚·å®³ã€‚`);
                        flashBattleView('hero-hit');
                        if (hero.equipment.RING.ability && hero.equipment.RING.ability.id === 'HEAL') {
                            const heal = hero.equipment.RING.ability.effect(hero);
                            log(`ğŸ’– ç”Ÿå‘½æˆ’æŒ‡: é˜²ç¦¦æˆåŠŸï¼Œæ¢å¾© ${heal} HP!`);
                            flashBattleView('heal');
                            updateStatus();
                        }
                    }
                }
            }

            updateBattleView();
            if (currentEnemy.hp <= 0) {
                setTimeout(() => endBattle('win'), 1500);
                battleEnded = true;
                return;
            }

            await new Promise(resolve => setTimeout(resolve, 800));

            if (isHeroWin) {
                log(`ğŸ›¡ï¸ æ€ªç‰© ${monsterMove} è¢« ${playerMove} å…‹åˆ¶ï¼Œæ‹›å¼ç„¡æ•ˆã€‚`);
            } else if (isMonsterWin || playerMove === monsterMove) {
                if (hero.equipment.RING.ability &&
                    hero.equipment.RING.ability.id === 'DODGE' &&
                    Math.random() * 100 < hero.currentDodge) {
                    log(`ğŸ’¨ æ•æ·æŒ‡ç’°: æˆåŠŸé–ƒé¿äº† ${currentEnemy.name} çš„æ”»æ“Š!`);
                    flashBattleView('heal');
                } else {
                    let monsterDamage = Math.max(1, currentEnemy.atk - hero.currentDefense);
                    applyDamageToHero(monsterDamage);
                    log(`ğŸ’¥ ${currentEnemy.name} ${monsterMove} æ”»æ“Šï¼Œé€ æˆ ${monsterDamage} é»å‚·å®³!`);
                    flashBattleView('monster-hit');
                }
            }

            updateStatus();
            if (hero.hp <= 0) {
                setTimeout(() => endBattle('lose'), 1500);
                battleEnded = true;
                return;
            }
        } finally {
            if (!battleEnded && gameState === 'BATTLE') {
                disableCommands(false);
            }
        }
    }

    function gainExp(amount) {
        if (hero.level >= MAX_LEVEL) return;
        hero.exp += amount;
        log(`ç²å¾—äº† ${amount} é»ç¶“é©—å€¼!`);

        while (hero.exp >= hero.expToNextLevel && hero.level < MAX_LEVEL) {
            hero.exp -= hero.expToNextLevel;
            levelUp();
        }
        updateStatus();
    }

    function levelUp() {
        if (hero.level >= MAX_LEVEL) return;
        const oldLevel = hero.level;
        hero.level++;
        hero.expToNextLevel = Math.floor(hero.expToNextLevel * 1.15) + 3;

        if (hero.level > hero.highestLevel) {
            hero.highestLevel = hero.level;

            hero.maxHp += HP_PER_LEVEL;
            const atkGain   = randInt(1, 3);
            const defGain   = randInt(1, 3);
            const dodgeGain = randInt(1, 3);
            const tieGain   = randInt(1, 3);
            const matkGain  = randInt(3, 5);

            hero.baseAttack     += atkGain;
            hero.baseDefense    += defGain;
            hero.baseDodge      += dodgeGain;
            hero.baseTieWinRate += tieGain;
            hero.baseMagicAtk   += matkGain;

            hero.hp = hero.maxHp;
            log(`ğŸ‰ å‡ç´š! Lv.${oldLevel} â†’ Lv.${hero.level} (é¦–æ¬¡é”åˆ°è©²ç­‰ç´š)`);
            log(`   HP +${HP_PER_LEVEL}ï¼ŒATK +${atkGain}ï¼ŒDEF +${defGain}ï¼Œé–ƒé¿ +${dodgeGain}% ï¼Œå¹³æ‰‹å‹ç‡ +${tieGain}% ï¼ŒMATK +${matkGain}`);
        } else {
            hero.maxHp += HP_PER_LEVEL;
            hero.hp = hero.maxHp;
            log(`â¬†ï¸ å›åˆ°æ›¾ç¶“åˆ°éçš„ç­‰ç´š Lv.${hero.level}ï¼Œåªæ¢å¾©æœ€å¤§ HPï¼Œä¸å†è¿½åŠ èƒ½åŠ›æˆé•·ã€‚`);
        }
    }

    function unlockNewRarity() {
        if (bossLevel === 2) {
            log(`ğŸ‰ å·²æ“Šæ•— Boss 1ï¼šé–‹å§‹æœ‰æ©Ÿæœƒæ‰è½ <span class="${RARITY_COLORS['Legendary']}">æ©˜æ­¦ã€æ©˜ç›¾</span>ï¼`);
        } else if (bossLevel === 3) {
            log(`ğŸ‰ å·²æ“Šæ•— Boss 2ï¼šé–‹å§‹æœ‰æ©Ÿæœƒæ‰è½ <span class="${RARITY_COLORS['Mythic']}">ç´…æ­¦ã€ç´…ç›¾</span>ï¼`);
        }
    }

    function showCredits() {
        gameState = 'CREDITS';
        disableCommands(true);
        mainView.style.backgroundColor = '#000';
        mainView.style.whiteSpace = 'pre-line';
        mainView.innerHTML = `
ğŸ‰ å²è©©ç´šå‹åˆ©ï¼ä¸–ç•Œæ¢å¾©äº†å’Œå¹³ ğŸ‰

ã€ä¸–ç•Œå’Œå¹³è¨ˆç•« - æœ€çµ‚è£½ä½œåå–®ã€‘

éŠæˆ²æ¦‚å¿µ / åŸå‰µä½œè€…ï¼šJack
ç¸½ç›£ (Director)ï¼šJack
ç¨‹å¼ç¢¼æ’°å¯« (Code)ï¼šJack
ç¾è¡“è¨­è¨ˆ (ASCII Art)ï¼šJack
éŠæˆ²å¹³è¡¡ / æ•¸å€¼ (Balance)ï¼šJack

ç‰¹åˆ¥æ„Ÿè¬ï¼šæ­£åœ¨ç©é€™å€‹ç¶²é çš„ä½ 

ï¼ˆ25 ç§’å¾Œè‡ªå‹•å›åˆ°åœ°åœ–ç•«é¢ï¼Œç¹¼çºŒæ‰“å¯¶ï¼‰`;

        setTimeout(() => {
            enterMap();
        }, 25000);
    }

    async function endBattle(result) {
        disableCommands(true);
        currentEnemy.hp = Math.max(0, currentEnemy.hp);

        if (result === "win") {
            const expGained = currentEnemy.exp;
            gainExp(expGained);
            log(`ğŸ† æ“Šæ•—äº† ${currentEnemy.name}!`);

            const isBoss = ENEMIES.BOSS.some(b => b.name === currentEnemy.name);
            if (isBoss) {
                if (bossLevel <= ENEMIES.BOSS.length) {
                    unlockNewRarity();
                    bossLevel++;
                    if (bossLevel <= ENEMIES.BOSS.length) {
                        log(`ğŸ‰ æ–°çš„æŒ‘æˆ°è§£é–! Boss ${bossLevel} å¯¶è—å·²é–‹å•Ÿ!`);
                    }
                }
                if (bossLevel > ENEMIES.BOSS.length) {
                    log("ğŸ‘‘ æ­å–œ! ä½ æ“Šæ•—äº†æ‰€æœ‰ Bossï¼Œä¸–ç•Œæ¢å¾©äº†å’Œå¹³!");
                    showCredits();
                    return;
                }
            }

            await handleLootDrop(currentEnemy, isBoss);
        } else if (result === "lose") {
            log("ğŸ’€ å‹‡è€…å€’ä¸‹äº†... ä½ çš„å†’éšªæš«æ™‚å‘Šä¸€æ®µè½ã€‚");
            applyDeathPenalty();
        }

        const isFinalBoss = result === 'win' &&
            ENEMIES.BOSS.length > 0 &&
            currentEnemy.name === ENEMIES.BOSS[ENEMIES.BOSS.length - 1].name;

        if (!isFinalBoss && gameState !== 'LOOT_RING_DECISION' && gameState !== 'CREDITS') {
            setTimeout(enterMap, 2000);
        }
    }

    function applyDeathPenalty() {
        if (hero.level === 1) {
            log("å¹¸é‹çš„æ˜¯ï¼Œæ–°æ‰‹éšæ®µä¸æœƒå—åˆ°æ­»äº¡æ‡²ç½°ã€‚");
            hero.hp = hero.maxHp;
            updateStatus();
            setTimeout(enterMap, 2000);
            return;
        }
        const expLoss = Math.floor(hero.expToNextLevel * 0.5);
        hero.exp -= expLoss;
        log(`âš¡ å› æˆ°æ•—ï¼Œä½ æå¤±äº† ${expLoss} é»ç¶“é©—å€¼ã€‚`);

        if (hero.exp < 0) {
            log(`ğŸ”¥ ç¶“é©—å€¼ä¸è¶³! å‹‡è€…é™ç´šäº†!`);
            const oldLevel = hero.level;
            hero.level = Math.max(1, hero.level - 1);

            let currentExpToNext = 10;
            let tempLevel = 2;
            while (tempLevel <= hero.level) {
                currentExpToNext = Math.floor(currentExpToNext * 1.15) + 3;
                tempLevel++;
            }
            hero.expToNextLevel = currentExpToNext;
            hero.exp = Math.max(0, hero.expToNextLevel + hero.exp);

            hero.maxHp = Math.max(HERO_MAX_HP_START + (hero.level - 1) * HP_PER_LEVEL, HERO_MAX_HP_START);
            hero.hp = hero.maxHp;
            log(`â¬‡ï¸ ç­‰ç´šå¾ Lv.${oldLevel} é™åˆ° Lv.${hero.level}ï¼Œæœ€å¤§ HP è·Ÿè‘—é™ä½ï¼Œå…¶é¤˜èƒ½åŠ›ä¿ç•™ã€‚`);
        } else {
            hero.hp = hero.maxHp;
        }
        updateStatus();
        setTimeout(enterMap, 2000);
    }

    function getRandomRarity(lootType, isBoss = false) {
        let phase = 0;
        if (bossLevel > 1) phase = 1;
        if (bossLevel > 2) phase = 2;

        const baseTable0 = [
            { rarity: 'Mythic',    weight: 0 },
            { rarity: 'Legendary', weight: 0 },
            { rarity: 'Epic',      weight: 15 },
            { rarity: 'Rare',      weight: 18 },
            { rarity: 'Magic',     weight: 23 },
            { rarity: 'Normal',    weight: 30 }
        ];
        const baseTable1 = [
            { rarity: 'Mythic',    weight: 0 },
            { rarity: 'Legendary', weight: 10 },
            { rarity: 'Epic',      weight: 15 },
            { rarity: 'Rare',      weight: 18 },
            { rarity: 'Magic',     weight: 23 },
            { rarity: 'Normal',    weight: 30 }
        ];
        const baseTable2 = [
            { rarity: 'Mythic',    weight: 4 },
            { rarity: 'Legendary', weight: 10 },
            { rarity: 'Epic',      weight: 15 },
            { rarity: 'Rare',      weight: 18 },
            { rarity: 'Magic',     weight: 23 },
            { rarity: 'Normal',    weight: 30 }
        ];

        let table;
        if (phase === 0) table = baseTable0;
        else if (phase === 1) table = baseTable1;
        else table = baseTable2;

        if (lootType === 'RING') {
            table = [
                { rarity: 'Mythic',    weight: 0 },
                { rarity: 'Legendary', weight: 5 },
                { rarity: 'Epic',      weight: 12 },
                { rarity: 'Rare',      weight: 20 },
                { rarity: 'Magic',     weight: 25 },
                { rarity: 'Normal',    weight: 20 }
            ];
        }

        const total = table.reduce((sum, e) => sum + e.weight, 0) || 1;
        let r = Math.random() * total;
        for (const e of table) {
            if (r < e.weight) return e.rarity;
            r -= e.weight;
        }
        return 'Normal';
    }

    function getPowerRange(rarity, isWeapon, isBoss) {
        const base = isWeapon ? 10 : 5;
        const multiplier = isWeapon ? 1.5 : 1;
        const bossBonus = isBoss ? hero.level * 0.5 : 0;
        switch (rarity) {
            case 'Mythic':   return { min: (base * 5.0 * multiplier) + bossBonus * 15, max: (base * 6.5 * multiplier) + bossBonus * 15 };
            case 'Legendary':return { min: (base * 4.0 * multiplier) + bossBonus * 10, max: (base * 5.0 * multiplier) + bossBonus * 10 };
            case 'Epic':     return { min: (base * 3.0 * multiplier) + bossBonus * 5,  max: (base * 4.0 * multiplier) + bossBonus * 5 };
            case 'Rare':     return { min: (base * 2.0 * multiplier) + bossBonus * 2,  max: (base * 3.0 * multiplier) + bossBonus * 2 };
            case 'Magic':    return { min: (base * 1.0 * multiplier) + bossBonus * 1,  max: (base * 2.0 * multiplier) + bossBonus * 1 };
            default:         return { min: base * 0.5 * multiplier, max: base * 1.0 * multiplier };
        }
    }

    function generateLoot(type, isBoss) {
        let rarity = getRandomRarity(type, isBoss);

        if (type === 'RING') {
            const abilityIndex = Math.floor(Math.random() * (RING_ABILITIES.length - 1));
            const ability = RING_ABILITIES[abilityIndex];
            let tier = 1;
            if (isBoss) tier = Math.min(4, bossLevel + 1);
            else tier = Math.min(2, Math.ceil(Math.random() * 2));
            return { type: 'RING', name: ability.name, ability: ability, tier: tier, rarity: rarity };
        }

        const isWeapon = type === 'WEAPON';
        const range = getPowerRange(rarity, isWeapon, isBoss);
        const power = Math.floor(Math.random() * (range.max - range.min) + range.min) + 1;
        const name = isWeapon ? `${rarity}ä¹‹åŠ` : `${rarity}ä¹‹ç›¾`;
        const equip = {
            type, name, power, rarity,
            refine: type === 'SHIELD' ? 0 : undefined,
            affixes: [],
            refineSlots: type === 'SHIELD' ? 0 : undefined
        };

        const baseSlotsByRarity = {
            Normal: 0, Magic: 0, Rare: 0, Epic: 1, Legendary: 2, Mythic: 3
        };
        const baseSlots = baseSlotsByRarity[rarity] || 0;
        const pool = isWeapon ? WEAPON_AFFIX_POOL : SHIELD_AFFIX_POOL;
        for (let i = 0; i < baseSlots; i++) {
            addRandomAffix(equip, pool);
        }
        return equip;
    }

    async function handleLootDrop(enemy, isBoss) {
        if (Math.random() > enemy.lootChance) return;
        const lootType = ['WEAPON', 'SHIELD', 'RING'][Math.floor(Math.random() * 3)];
        const loot = generateLoot(lootType, isBoss);
        await showLootAnimation(loot);

        log(`âœ¨ ${enemy.name} æ‰è½äº† <span class="${RARITY_COLORS[loot.rarity] || 'Rarity-Rare'}">${loot.name}</span>!`);

        if (lootType === 'RING') {
            const currentRing = hero.equipment.RING;
            if (currentRing.ability && currentRing.ability.id === loot.ability.id && currentRing.ability.id !== 'NONE') {
                if (currentRing.tier < 4) {
                    currentRing.tier = Math.min(4, currentRing.tier + 1);
                    if (RARITY_ORDER.indexOf(loot.rarity) > RARITY_ORDER.indexOf(currentRing.rarity)) {
                        currentRing.rarity = loot.rarity;
                    }
                    log(`ğŸ’ æ‰“åˆ°ç›¸åŒæˆ’æŒ‡ï¼š${currentRing.name} å‡ç´šç‚º Lv.${currentRing.tier}ï¼`);
                } else {
                    log(`ğŸ’ ${currentRing.name} å·²æ˜¯ Lv.4ï¼Œç›¸åŒæˆ’æŒ‡è‡ªå‹•åˆ†è§£ï¼ˆç›®å‰ä¸çµ¦é¡å¤–æ•ˆæœï¼‰ã€‚`);
                }
                updateStatus();
                return;
            }
            newLoot = loot;
            enterRingDecision();
            return;
        }

        if (lootType === 'WEAPON') {
            const currentW = hero.equipment.WEAPON;

            if (!currentW || currentW.name === "å¾’æ‰‹") {
                hero.equipment.WEAPON = loot;
                log(`ğŸ‘ è£å‚™äº†æ–°çš„ <span class="${RARITY_COLORS[loot.rarity]}">${loot.name}</span>ï¼`);
                updateStatus();
                return;
            }

            const lootRIndex = RARITY_ORDER.indexOf(loot.rarity);
            const curRIndex  = RARITY_ORDER.indexOf(currentW.rarity);

            let isBetter = false;
            if (lootRIndex > curRIndex) isBetter = true;
            else if (lootRIndex === curRIndex && loot.power > currentW.power) isBetter = true;

            if (isBetter) {
                const matOld = RARITY_MATERIAL_VALUE[currentW.rarity] || 0;
                if (matOld > 0 && currentW.name !== "å¾’æ‰‹") {
                    weaponMaterials += matOld;
                    log(`ğŸ”§ åŸæœ¬çš„ <span class="${RARITY_COLORS[currentW.rarity]}">${currentW.name}</span> è¢«åˆ†è§£ç‚ºæ­¦å™¨ç´ æ x${matOld}ã€‚ (æ­¦å™¨ç´ æ: ${weaponMaterials}/${WEAPON_MATERIAL_PER_REFINE})`);
                    while (weaponMaterials >= WEAPON_MATERIAL_PER_REFINE) {
                        weaponMaterials -= WEAPON_MATERIAL_PER_REFINE;
                        attemptWeaponRefine();
                    }
                }
                hero.equipment.WEAPON = loot;
                log(`â­ æ–°æ­¦å™¨æ›´å¼·ï¼å·²æ›´æ›ç‚º <span class="${RARITY_COLORS[loot.rarity]}">${loot.name}</span>ï¼`);
                updateStatus();
            } else {
                const mat = RARITY_MATERIAL_VALUE[loot.rarity] || 0;
                if (mat > 0) {
                    weaponMaterials += mat;
                    log(`ğŸ”§ <span class="${RARITY_COLORS[loot.rarity]}">${loot.name}</span> è¢«åˆ†è§£ç‚ºæ­¦å™¨ç´ æ x${mat}ã€‚ (æ­¦å™¨ç´ æ: ${weaponMaterials}/${WEAPON_MATERIAL_PER_REFINE})`);
                    while (weaponMaterials >= WEAPON_MATERIAL_PER_REFINE) {
                        weaponMaterials -= WEAPON_MATERIAL_PER_REFINE;
                        attemptWeaponRefine();
                    }
                } else {
                    log(`ğŸ‘ ç°è‰²æ­¦å™¨å“è³ªå¤ªå·®ï¼Œè¢«ä¸Ÿæ£„ã€‚`);
                }
                updateStatus();
            }
            return;
        }

        const currentS = hero.equipment.SHIELD;
        if (!currentS || currentS.name === "ç„¡") {
            hero.equipment.SHIELD = loot;
            log(`ğŸ‘ è£å‚™äº†æ–°çš„ <span class="${RARITY_COLORS[loot.rarity]}">${loot.name}</span>ï¼`);
            updateStatus();
            return;
        }

        const lootRIndex = RARITY_ORDER.indexOf(loot.rarity);
        const curRIndex  = RARITY_ORDER.indexOf(currentS.rarity);
        let betterShield = false;
        if (lootRIndex > curRIndex) betterShield = true;
        else if (lootRIndex === curRIndex && loot.power > currentS.power) betterShield = true;

        if (betterShield) {
            hero.equipment.SHIELD = loot;
            log(`â­ æ–°ç›¾ç‰Œæ›´å¼·ï¼å·²æ›´æ›ç‚º <span class="${RARITY_COLORS[loot.rarity]}">${loot.name}</span>ï¼`);
            updateStatus();
        } else {
            const mat = RARITY_MATERIAL_VALUE[loot.rarity] || 0;
            if (mat > 0) {
                shieldMaterials += mat;
                log(`ğŸ”© <span class="${RARITY_COLORS[loot.rarity]}">${loot.name}</span> è¢«åˆ†è§£ç‚ºç›¾ç‰Œç´ æ x${mat}ã€‚ (ç›¾ç‰Œç´ æ: ${shieldMaterials}/${SHIELD_MATERIAL_PER_REFINE})`);
                while (shieldMaterials >= SHIELD_MATERIAL_PER_REFINE) {
                    shieldMaterials -= SHIELD_MATERIAL_PER_REFINE;
                    attemptShieldRefine();
                }
            } else {
                log(`ğŸ‘ ç°è‰²ç›¾ç‰Œå“è³ªå¤ªå·®ï¼Œè¢«ä¸Ÿæ£„ã€‚`);
            }
            updateStatus();
        }
    }

    function enterRingDecision() {
        gameState = 'LOOT_RING_DECISION';
        commandMenu.style.display = 'none';
        decisionMenu.style.display = 'flex';

        const currentRing = hero.equipment.RING;
        const newRing = newLoot;

        const currentRingColor = RARITY_COLORS[currentRing.rarity];
        const newRingColor = RARITY_COLORS[newRing.rarity];

        const currentRingNameHtml = `<span class="${currentRingColor}">${currentRing.name}</span>`;
        const newRingNameHtml = `<span class="${newRingColor}">${newRing.name}</span>`;

        let decisionText = `ğŸ’ æ›ä¸Š Lv.${newRing.tier} çš„ ${newRing.name}`;

        mainView.style.backgroundColor = '#2c3e50';
        mainView.innerHTML = `
<p style="color:#ffcc00;">ğŸ”” ç™¼ç¾æ–°æˆ’æŒ‡! è«‹æ‰‹å‹•é¸æ“‡æ˜¯å¦æ›¿æ›æˆ–å‡ç´š</p>
<p style="text-align: left; padding: 0 20px;">
ã€ç¾æœ‰æˆ’æŒ‡ã€‘ï¼š${currentRingNameHtml} (${currentRing.ability.desc}, Lv.${currentRing.tier})<br>
ã€æ–°æˆ’æŒ‡ã€‘ï¼š${newRingNameHtml} (${newRing.ability.desc}, Lv.${newRing.tier})
</p>
        `;
        btnDecYes.textContent = decisionText;
        btnDecNo.textContent = `ğŸš« ä¿ç•™ Lv.${currentRing.tier} çš„ ${currentRing.name} (ä¸Ÿæ£„æ–°)`;
    }

    function handleRingDecision(choice) {
        if (gameState !== 'LOOT_RING_DECISION') return;
        const currentRing = hero.equipment.RING;
        const newRing = newLoot;

        if (choice === 'YES') {
            hero.equipment.RING = newRing;
            log(`ğŸ’ æ‰‹å‹•ç¢ºèª: æˆåŠŸæ›ä¸Šäº† Lv.${newRing.tier} çš„ <span class="${RARITY_COLORS[newRing.rarity]}">${newRing.name}</span>!`);
        } else {
            log(`ğŸ—‘ï¸ æ‰‹å‹•ç¢ºèª: æ”¾æ£„äº† <span class="${RARITY_COLORS[newRing.rarity]}">${newRing.name}</span>ã€‚`);
        }
        newLoot = null;
        updateStatus();
        decisionMenu.style.display = 'none';
        setTimeout(enterMap, 500);
    }

    function disableCommands(disabled) {
        commandMenu.querySelectorAll('.command-btn').forEach(btn => btn.disabled = disabled);
        if (disabled) decisionMenu.style.display = 'none';
    }

    // åˆå§‹åŒ–æˆ’æŒ‡ç‚º NONE
    hero.equipment.RING = {
        name: "ç„¡",
        ability: RING_ABILITIES.find(a => a.id === 'NONE'),
        tier: 0,
        rarity: 'Normal'
    };
    calculateHeroStats();
    updateStatus();
    enterMap();
</script>

</body>
</html>
